# ArrayList åˆ—è¡¨

## å†…å­˜æ˜¯ä¸€ç§èµ„æº

Zigä¸ä¼šä»£æ›¿ç¨‹åºå‘˜ç®¡ç†å†…å­˜ï¼Œå› æ­¤ï¼Œä½¿ç”¨Zigè¿›è¡Œç¼–ç¨‹çš„äººå¿…é¡»çŸ¥é“æ€ä¹ˆç®¡ç†å†…å­˜ã€‚

å½“ç„¶ï¼Œå°±æˆ‘ä»¬çš„ä¸»é¢˜è€Œè¨€ï¼Œä½ å¹¶ä¸éœ€è¦éå¸¸ç†Ÿæ‚‰æ€ä¹ˆè¿›è¡Œç®¡ç†ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šåœ¨è¿™æ–¹é¢æ·±å…¥å¤ªå¤šã€‚

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åªä»‹ç»ä¸€ç§ç®€å•çš„å†…å­˜ç®¡ç†æ–¹å¼ï¼Œæœ‰å…³å†…å­˜çš„è¯¦ç»†å¯è§[è¿™ä¸ªç½‘ç«™](https://ziglang.org/documentation/master/#Memory)ã€‚

### ArenaAllocator

åœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬å®ç°çš„æ•°æ®ç»“æ„å¹¶ä¸ä¼šè¢«æŠ•å…¥åˆ°å®é™…çš„ç”Ÿäº§å¼€å‘ä¸­ï¼ˆæˆ‘ä¸å»ºè®®è¿™ä¹ˆåšï¼‰ï¼Œæ‰€æœ‰çš„æ•°æ®ç»“æ„çš„å®ä¾‹éƒ½åªä¼šå­˜åœ¨å¾ˆçŸ­çš„ä¸€æ®µæ—¶é—´ï¼Œå› æ­¤ï¼Œå®Œå…¨å¯ä»¥ä½¿ç”¨ArenaAllocatoræ¥åˆ†é…å†…å­˜ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€æ¬¡æ€§æ–½æ”¾ç”³è¯·çš„æ‰€æœ‰å†…å­˜ã€‚å¦‚æœä½ æƒ³çŸ¥é“ArenaAllocatoræ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Œå¯ä»¥æŸ¥çœ‹[è¿™ä¸ªç½‘ç«™](https://www.huy.rocks/everyday/01-12-2022-zig-how-arenaallocator-works)ã€‚

è®©æˆ‘ä»¬æ¥åˆ†é…ç‚¹ä¸œè¥¿å§ï¼

```zig
var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
const allocator = arena.allocator();
const a_number = try allocator.create(u32);
a_number.* = 100;
std.debug.print("We allocated {p} which stores {d}!\n", .{ a_number, a_number.* });
arena.deinit();
```

```ansi
$stdout returns nothing.
$stderr:
We allocated u32@151ed1796010 which stores 100!
```

è®©æˆ‘ä»¬æ¥é€è¡Œçœ‹çœ‹æœ‰ä»€ä¹ˆå§ï¼

1. `var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);`ï¼šé€šè¿‡ä¼ å…¥ä¸€ä¸ªå…¶ä»–çš„Allocatorï¼Œæˆ‘ä»¬åˆå§‹åŒ–äº†ä¸€ä¸ªArenaAllocatorã€‚ArenaAllocatorä¼šç”¨è¿™ä¸ªåˆ†é…å™¨æ¥å®é™…åˆ†é…å†…å­˜ï¼›
2. `const allocator = arena.allocator();`ï¼šæˆ‘ä»¬ä»arenaä¸­è¦äº†ä¸€ä¸ªAllocatorï¼Œè¿™æ˜¯æˆ‘ä»¬ç”¨å®ƒæ¥åˆ†é…å†…å­˜ï¼›
3. `const a_number = try allocator.create(u32);`ï¼šæˆ‘ä»¬ä»å†…å­˜ä¸­è¦æ¥äº†ä¸€å—èƒ½æ”¾ä¸‹u32ç±»å‹çš„ç©ºé—´ï¼Œcreateå‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªé”™è¯¯è”åˆç±»å‹ï¼Œé€šè¿‡tryæˆ‘ä»¬æ‹¿å‡ºäº†å®é™…çš„å€¼â€”â€”ä¸€ä¸ªæŒ‡å‘åˆ†é…çš„å†…å­˜åŒºåŸŸçš„æŒ‡é’ˆã€‚å¦‚æœä½ å¿˜äº†é”™è¯¯è”åˆç±»å‹ï¼Œå¯ä»¥çœ‹çœ‹[ä¸Šä¸€ç« ](./01_zig_basics)ã€‚
4. `a_number.* = 100;`ï¼šæˆ‘ä»¬å‘åˆšæ‰åˆ†é…çš„å†…å­˜å†™äº†100è¿™ä¸ªæ•°å­—ï¼›
5. `std.debug.print("We allocated {p} which stores {d}!\n", .{ a_number, a_number.* });`ï¼š æ‰“å°å®ƒï¼
6. `arena.deinit();`ï¼šå½“æˆ‘ä»¬ä¸å†ä½¿ç”¨arenaåï¼Œä¸€å®šè¦ååˆå§‹åŒ–ï¼ˆdeinitï¼‰å®ƒï¼Œæ¥æ–½æ”¾æ‰€æœ‰çš„å†…å­˜ã€‚

åœ¨åé¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ç»å¸¸è§åˆ°ç±»ä¼¼çš„ç‰‡æ®µã€‚

## ç»“æ„ä½“

ä¸ºäº†å®ç°ä¸€ç§æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåœ°æ–¹å­˜å‚¨æ•°æ®ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æœ‰â€œç»“æ„â€ã€‚

å¦‚æœä½ æœ‰ä½¿ç”¨Cçš„ç»éªŒï¼Œä½ åº”è¯¥å¯¹ä¸‹é¢çš„ä»£ç ä¸ä¼šé™Œç”Ÿï¼š

```zig
const Point = struct {
    // ç»“æ„ä½“
    x: f32, // æˆå‘˜
    y: f32, // æˆå‘˜
};
```

å¦‚æœä½ è§‰å¾—é™Œç”Ÿä¹Ÿæ²¡å…³ç³»ï¼Œæˆ‘ä»¬æ…¢æ…¢è§£é‡Šã€‚

é¦–å…ˆï¼Œåœ¨`const Point = struc {};`è¿™é‡Œæˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªåä¸ºPointçš„å˜é‡ï¼Œå¹¶ä¸ºå…¶èµ‹å€¼ä¸ºä¸€ä¸ªç»“æ„ä½“ã€‚åœ¨Zigä¸­ï¼Œç±»å‹æ˜¯â€œä¸€ç­‰å…¬æ°‘â€ï¼Œå®ƒå¯ä»¥åƒå€¼ã€æŒ‡é’ˆä¸€æ ·è¢«èµ‹äºˆå˜é‡ã€‚

åœ¨ä¸¤ä¸ªèŠ±æ‹¬å·ä¹‹é—´çš„éƒ¨åˆ†ï¼Œè¢«ç§°ä¸ºç»“æ„ä½“ã€‚åœ¨ç»“æ„ä½“å†…å¯ä»¥å£°æ˜è¿™ä¸ªç»“æ„çš„æˆå‘˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å£°æ˜äº†ä¸¤ä¸ªç±»å‹ä¸ºf32çš„æˆå‘˜â€”â€”xå’Œyã€‚

æœ‰äº†ç»“æ„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒç”¨èµ·æ¥ã€‚

```zig {3}
const std = @import("std");
pub fn main() void {
    const point = Point{
        .x = 1.0,
        .y = 1.80086,
    };

    std.debug.print("We got a point ({}, {}).\n", .{ point.x, point.y });
}
```

```ansi
$stdout returns nothing.
$stderr:
We got a point (1e0, 1.80086e0).
```

æœ‰ä¸¤ä¸ªç‚¹éœ€è¦è§£é‡Šä¸€ä¸‹ã€‚

é¦–å…ˆï¼Œåœ¨ç¬¬3è¡Œï¼Œæˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªpointå˜é‡ï¼Œç„¶ååˆå§‹åŒ–äº†ä¸€ä¸ªPointç»“æ„å¹¶èµ‹å€¼ç»™å®ƒã€‚åˆå§‹åŒ–è¯­å¥ä¹Ÿå’ŒCé‡Œé¢éå¸¸ç›¸ä¼¼ã€‚

å…¶æ¬¡ï¼Œæˆ‘ä»¬æ‰“å°äº†pointé‡Œå­˜å‚¨çš„å€¼ã€‚è¿™é‡Œçš„`point.x`å’Œ`point.y`åˆ†åˆ«è®¿é—®äº†ä¸¤ä¸ªæˆå‘˜ï¼Œ`.`å«ä½œæˆå‘˜è®¿é—®è¿ç®—ç¬¦ã€‚

## æ•°ç»„

æ•°ç»„ï¼ˆArrayï¼‰æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œå®ƒç”±ç›¸åŒç±»å‹çš„æ•°æ®å…ƒç´ ç»„æˆï¼Œè¿™äº›å…ƒç´ å­˜å‚¨åœ¨è¿ç»­çš„åŒºåŸŸå†…ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡ä¸‹æ ‡è¿›è¡Œè®¿é—®ã€‚

ä¸‹é¢çš„å›¾ç‰‡æ˜¯ä¸€ä¸ªæ•°ç»„ç¤ºä¾‹ï¼Œè¿™ä¸ªæ•°ç»„ä¸­å­˜å‚¨äº†5ä¸ªç±»å‹ä¸ºi8çš„æ•´å‹æ•°å­—ï¼Œå› æ­¤é•¿åº¦ä¸º5ã€‚åŒæ—¶ï¼Œç®­å¤´æŒ‡å‘äº†ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ çš„ä¸‹æ ‡æ˜¯0ã€‚

![æ•°ç»„ç¤ºä¾‹](./imgs/02/0201_Array.png)

æˆ‘ä»¬å·²ç»è§è¿‡åœ¨Zigæ€ä¹ˆåˆ›å»ºå’Œè®¿é—®ä¸€æ ·çš„æ•°ç»„ï¼š

```zig
const number = [5]i8{ 2, -1, 5, 6, 3 };
for (number, 0..) |value, i| {
    std.debug.print("Index={}, Value={}\n", .{ i, value });
}
std.debug.print("number.len={}\n", .{number.len});
```

```ansi
$stdout returns nothing.
$stderr:
Index=0, Value=2
Index=1, Value=-1
Index=2, Value=5
Index=3, Value=6
Index=4, Value=3
number.len=5
```

åœ¨å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ•°ç»„çš„é•¿åº¦éƒ½æ˜¯å›ºå®šçš„ï¼Œå¿…é¡»è¦ç¼–è¯‘çš„æ—¶å€™å°±ç¡®å®šé•¿åº¦ã€‚

## å˜é•¿çš„æ•°ç»„ â€”â€” åˆ—è¡¨

å¦‚æœæˆ‘ä»¬æƒ³è¦åŠ¨æ€åœ°è°ƒæ•´æ•°ç»„é•¿åº¦å‘¢ï¼Ÿåœ¨Pythonä¸­ï¼Œå¸¸ç”¨çš„åˆ—è¡¨å¯ä»¥è‡ªåŠ¨è°ƒæ•´é•¿åº¦ï¼›åœ¨Rustä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‘é‡Vecã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨**åˆ—è¡¨**è¿™ä¸ªç§°å‘¼ï¼Œå°†æˆ‘ä»¬å®ç°çš„ç‰ˆæœ¬å‘½åä¸ºSimpleArrayListã€‚

::: tip
Zigè¯­è¨€çš„æ ‡å‡†åº“æä¾›äº†ä¸€ä¸ªåˆ—è¡¨çš„å®ç°[std.ArrayList](https://ziglang.org/documentation/master/std/#std.ArrayList)ï¼Œæˆ‘ä»¬è·Ÿéšæ ‡å‡†åº“ç§°ä¹‹ä¸ºåˆ—è¡¨ï¼ˆListï¼‰ã€‚
:::

æ­£å¦‚å…¶åï¼ŒSimpleArrayListä½¿ç”¨æ™®é€šçš„æ•°ç»„å­˜å‚¨æ•°æ®ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å­˜å‚¨äº†å¤šå°‘ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”éœ€è¦èƒ½åœ¨éœ€è¦æ—¶æ‰©å¤§å†…éƒ¨å­˜å‚¨ç”¨çš„æ•°ç»„ã€‚ç”±æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸‹é¢çš„åŸºæœ¬çš„å®šä¹‰ï¼š

```zig
const SimpleArrayList = struct {
    allocator: std.mem.Allocator,   // å†…å­˜åˆ†é…å™¨ï¼Œç”¨äºåŠ¨æ€åˆ†é…å†…å­˜
    items: []???,                  // åˆ—è¡¨å†…å…ƒç´ 
    len: usize,                     // åˆ—è¡¨å†…å…ƒç´ çš„æ•°é‡
};
```

### å®ç°**æ³›å‹**

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œ`items`åº”è¯¥æ˜¯ä»€ä¹ˆç±»å‹çš„å‘¢ï¼Ÿä¸ºäº†èƒ½ä½¿åˆ—è¡¨é€‚ç”¨äºä¸åŒç±»å‹çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦**æ³›å‹**ã€‚ç®€å•æ¥è¯´ï¼Œæ³›å‹å°±æ˜¯é€šè¿‡æŸç§æ–¹å¼ï¼Œä½¿å¾—å‡½æ•°æˆ–æ˜¯ç»“æ„ä½“å¯ä»¥æ¥æ”¶ä¸åŒçš„ç±»å‹ä½œä¸ºå‚æ•°æˆ–æˆå‘˜ã€‚

æˆ‘ä»¬å‰é¢è¯´è¿‡ï¼Œåœ¨Zigä¸­ç±»å‹æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥å°†ç±»å‹ä½œä¸ºå‚æ•°ä¼ ç»™å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºè¿”å›å€¼è¿”å›ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼å®ç°æ³›å‹ã€‚æˆ‘ä»¬å¯ä»¥å£°æ˜ä¸€ä¸ªå‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ªç±»å‹Tï¼Œç„¶åè¿”å›å­˜å‚¨ç±»å‹Tçš„å…ƒç´ çš„åˆ—è¡¨ã€‚

```zig
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,
    };
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬é‡åˆ°äº†å‡ ä¸ªæ²¡è§è¿‡çš„ä¸œè¥¿ï¼š

1. å…³é”®è¯`comptime`ï¼šè¿™æ˜¯Zigçš„ä¸€ä¸ªé‡è¦å±æ€§ï¼Œå®ƒæœ‰å¾ˆå¤šç”¨å¤„ï¼Œåœ¨è¿™é‡Œï¼Œå®ƒæ„å‘³ç€Tæ˜¯ä¸€ä¸ªåœ¨ç¼–è¯‘çš„æ—¶å€™å°±å·²çŸ¥çš„å€¼ï¼›
2. ç±»å‹`type`ï¼šè¿™ä¸ªç±»å‹æ˜¯â€œç±»å‹çš„ç±»å‹â€ï¼›

é€šè¿‡è¿™ç§æ–¹å¼è¿”å›çš„ç»“æ„ä½“çš„åå­—æ¯”è¾ƒå¤æ‚ï¼Œä¸æ–¹ä¾¿ä½¿ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨Zigçš„å†…å»ºå‡½æ•°æ¥æ„å»ºä¸€ä¸ªåˆ«åæ¥ã€‚

```zig {3}
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,
    };
}
```

åœ¨ç¬¬3è¡Œä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨`@This()`å‡½æ•°è·å¾—äº†å½“å‰ç»“æ„çš„ç±»å‹ã€‚

::: tip
åœ¨æ‰€æœ‰å†…å»ºå‡½æ•°ä¸­ï¼Œä»¥å¤§å†™å­—æ¯å¼€å¤´çš„å‡½æ•°éƒ½è¿”å›`type`ç±»å‹çš„å€¼ï¼Œä¾‹å¦‚è¿™é‡Œçš„`@This()`ã€‚

è¿™é‡Œçš„æˆå‘˜è¢«å‘½åä¸º`This`ï¼Œä½†è¿™ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œç”¨ä½ å–œæ¬¢çš„å°±è¡Œã€‚
:::

### åˆå§‹åŒ–å’Œååˆå§‹åŒ–

è®©æˆ‘ä»¬æ‰¾ä¸€ä¸ªåœ°æ–¹æ¥åˆå§‹åŒ–æ•°æ®ç»“æ„ã€‚

æŒ‰ç…§çº¦å®šä¿—æˆï¼Œä¸€èˆ¬å£°æ˜ä¸€ä¸ªåä¸º`init`çš„å‡½æ•°ä½œä¸ºåˆå§‹åŒ–å‡½æ•°ï¼Œä¸€ä¸ªåä¸º`deinit`çš„å‡½æ•°ä½œä¸ºååˆå§‹åŒ–å‡½æ•°ã€‚

å‡½æ•°åº”è¯¥æ”¾åœ¨å“ªé‡Œå‘¢ï¼Ÿåœ¨Cä¸­ï¼Œæˆ‘ä»¬æŠŠæˆå‘˜å®šä¹‰åœ¨ç»“æ„ä½“å†…ï¼Œç„¶ååœ¨ç»“æ„ä½“å¤–ç”¨ä¸€ä¸ªå¾ˆé•¿çš„å‰ç¼€æ¥åŒºåˆ†ï¼Œæ¯”å¦‚ï¼š

```c
typedef struct {
    int *items;
    int len;
} SimpleArrayListInt;

void simple_array_list_int_init(SimpleArrayListInt*);
```

åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬ä¼šç›´æ¥åœ¨ç±»çš„å®šä¹‰å†…å®šä¹‰ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ï¼Œæ¯”å¦‚ï¼š

```python
class SimpleArrayInit():
    def __init__(self):
        pass
```

åœ¨Zigä¸­ï¼Œæˆ‘ä»¬ç»“åˆè¿™ä¸¤ç§å½¢å¼ï¼šåœ¨ç»“æ„ä½“å†…å£°æ˜å‡½æ•°ï¼Œæ¯”å¦‚ï¼š

```zig {9}
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const DefaultCapacity: usize = 10;
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .items = try allocator.alloc(T, This.DefaultCapacity),
                .len = 0,
            };
        }
    };
}
```

é™¤äº†`init`ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå¯¹åº”çš„`deinit`ï¼Œä»¥ä¾¿åœ¨éœ€è¦çš„æ—¶å€™é‡Šæ”¾ç”³è¯·çš„å†…å­˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦é‡Šæ”¾`items`è¿™ä¸ªæˆå‘˜ã€‚

```zig
        pub fn deinit(self: This) void {
            self.allocator.free(self.items);
        }
```

ç»„è£…èµ·æ¥ï¼Œæˆ‘ä»¬å°±æœ‰äº†ä¸€ä¸ªSimpleArrayListçš„åŸºæœ¬æ¡†æ¶ï¼š

```zig
const std = @import("std");

pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const DefaultCapacity: usize = 10;
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .items = try allocator.alloc(T, This.DefaultCapacity),
                .len = 0,
            };
        }

        pub fn deinit(self: This) void {
            self.allocator.free(self.items);
        }
    };
}

pub fn main() !void {
    const a = try SimpleArrayList(i8).init(std.heap.page_allocator);
    defer a.deinit();
    std.debug.print("{} of {}\n", .{ a.len, a.items.len });
}
```

```ansi
$stdout returns nothing.
$stderr:
0 of 10
```

- åŠ¨æ€æ•°ç»„çš„ç®€å•å®ç°ï¼ˆæ‰©å®¹ç­–ç•¥ï¼‰
- åŸºç¡€å†…å­˜ç®¡ç†ç¤ºä¾‹

ğŸš§æ–½å·¥ä¸­ğŸš§


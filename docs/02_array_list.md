# ArrayList åˆ—è¡¨

## å†…å­˜æ˜¯ä¸€ç§èµ„æº

Zigä¸ä¼šä»£æ›¿ç¨‹åºå‘˜ç®¡ç†å†…å­˜ï¼Œå› æ­¤ï¼Œä½¿ç”¨Zigè¿›è¡Œç¼–ç¨‹çš„äººå¿…é¡»çŸ¥é“æ€Žä¹ˆç®¡ç†å†…å­˜ã€‚

å½“ç„¶ï¼Œå°±æˆ‘ä»¬çš„ä¸»é¢˜è€Œè¨€ï¼Œä½ å¹¶ä¸éœ€è¦éžå¸¸ç†Ÿæ‚‰æ€Žä¹ˆè¿›è¡Œç®¡ç†ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šåœ¨è¿™æ–¹é¢æ·±å…¥å¤ªå¤šã€‚

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åªä»‹ç»ä¸€ç§ç®€å•çš„å†…å­˜ç®¡ç†æ–¹å¼ï¼Œæœ‰å…³å†…å­˜çš„è¯¦ç»†å¯è§[è¿™ä¸ªç½‘ç«™](https://ziglang.org/documentation/master/#Memory)ã€‚

### ArenaAllocator

åœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬å®žçŽ°çš„æ•°æ®ç»“æž„å¹¶ä¸ä¼šè¢«æŠ•å…¥åˆ°å®žé™…çš„ç”Ÿäº§å¼€å‘ä¸­ï¼ˆæˆ‘ä¸å»ºè®®è¿™ä¹ˆåšï¼‰ï¼Œæ‰€æœ‰çš„æ•°æ®ç»“æž„çš„å®žä¾‹éƒ½åªä¼šå­˜åœ¨å¾ˆçŸ­çš„ä¸€æ®µæ—¶é—´ï¼Œå› æ­¤ï¼Œå®Œå…¨å¯ä»¥ä½¿ç”¨ArenaAllocatoræ¥åˆ†é…å†…å­˜ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€æ¬¡æ€§æ–½æ”¾ç”³è¯·çš„æ‰€æœ‰å†…å­˜ã€‚å¦‚æžœä½ æƒ³çŸ¥é“ArenaAllocatoræ˜¯æ€Žä¹ˆå·¥ä½œçš„ï¼Œå¯ä»¥æŸ¥çœ‹[è¿™ä¸ªç½‘ç«™](https://www.huy.rocks/everyday/01-12-2022-zig-how-arenaallocator-works)ã€‚

è®©æˆ‘ä»¬æ¥åˆ†é…ç‚¹ä¸œè¥¿å§ï¼

```zig
var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
const allocator = arena.allocator();
const a_number = try allocator.create(u32);
a_number.* = 100;
std.debug.print("We allocated {p} which stores {d}!\n", .{ a_number, a_number.* });
arena.deinit();
```

```ansi
$stdout returns nothing.
$stderr:
We allocated u32@151ed1796010 which stores 100!
```

è®©æˆ‘ä»¬æ¥é€è¡Œçœ‹çœ‹æœ‰ä»€ä¹ˆå§ï¼

1. `var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);`ï¼šé€šè¿‡ä¼ å…¥ä¸€ä¸ªå…¶ä»–çš„Allocatorï¼Œæˆ‘ä»¬åˆå§‹åŒ–äº†ä¸€ä¸ªArenaAllocatorã€‚ArenaAllocatorä¼šç”¨è¿™ä¸ªåˆ†é…å™¨æ¥å®žé™…åˆ†é…å†…å­˜ï¼›
2. `const allocator = arena.allocator();`ï¼šæˆ‘ä»¬ä»Žarenaä¸­è¦äº†ä¸€ä¸ªAllocatorï¼Œè¿™æ˜¯æˆ‘ä»¬ç”¨å®ƒæ¥åˆ†é…å†…å­˜ï¼›
3. `const a_number = try allocator.create(u32);`ï¼šæˆ‘ä»¬ä»Žå†…å­˜ä¸­è¦æ¥äº†ä¸€å—èƒ½æ”¾ä¸‹u32ç±»åž‹çš„ç©ºé—´ï¼Œcreateå‡½æ•°è¿”å›žçš„æ˜¯ä¸€ä¸ªé”™è¯¯è”åˆç±»åž‹ï¼Œé€šè¿‡tryæˆ‘ä»¬æ‹¿å‡ºäº†å®žé™…çš„å€¼â€”â€”ä¸€ä¸ªæŒ‡å‘åˆ†é…çš„å†…å­˜åŒºåŸŸçš„æŒ‡é’ˆã€‚å¦‚æžœä½ å¿˜äº†é”™è¯¯è”åˆç±»åž‹ï¼Œå¯ä»¥çœ‹çœ‹[ä¸Šä¸€ç« ](./01_zig_basics)ã€‚
4. `a_number.* = 100;`ï¼šæˆ‘ä»¬å‘åˆšæ‰åˆ†é…çš„å†…å­˜å†™äº†100è¿™ä¸ªæ•°å­—ï¼›
5. `std.debug.print("We allocated {p} which stores {d}!\n", .{ a_number, a_number.* });`ï¼š æ‰“å°å®ƒï¼
6. `arena.deinit();`ï¼šå½“æˆ‘ä»¬ä¸å†ä½¿ç”¨arenaåŽï¼Œä¸€å®šè¦ååˆå§‹åŒ–ï¼ˆdeinitï¼‰å®ƒï¼Œæ¥æ–½æ”¾æ‰€æœ‰çš„å†…å­˜ã€‚

åœ¨åŽé¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ç»å¸¸è§åˆ°ç±»ä¼¼çš„ç‰‡æ®µã€‚

## ç»“æž„ä½“

ä¸ºäº†å®žçŽ°ä¸€ç§æ•°æ®ç»“æž„ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåœ°æ–¹å­˜å‚¨æ•°æ®ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æœ‰â€œç»“æž„â€ã€‚

å¦‚æžœä½ æœ‰ä½¿ç”¨Cçš„ç»éªŒï¼Œä½ åº”è¯¥å¯¹ä¸‹é¢çš„ä»£ç ä¸ä¼šé™Œç”Ÿï¼š

```zig
const Point = struct {
    // ç»“æž„ä½“
    x: f32, // æˆå‘˜
    y: f32, // æˆå‘˜
};
```

å¦‚æžœä½ è§‰å¾—é™Œç”Ÿä¹Ÿæ²¡å…³ç³»ï¼Œæˆ‘ä»¬æ…¢æ…¢è§£é‡Šã€‚

é¦–å…ˆï¼Œåœ¨`const Point = struc {};`è¿™é‡Œæˆ‘ä»¬å£°æ˜Žäº†ä¸€ä¸ªåä¸ºPointçš„å˜é‡ï¼Œå¹¶ä¸ºå…¶èµ‹å€¼ä¸ºä¸€ä¸ªç»“æž„ä½“ã€‚åœ¨Zigä¸­ï¼Œç±»åž‹æ˜¯â€œä¸€ç­‰å…¬æ°‘â€ï¼Œå®ƒå¯ä»¥åƒå€¼ã€æŒ‡é’ˆä¸€æ ·è¢«èµ‹äºˆå˜é‡ã€‚

åœ¨ä¸¤ä¸ªèŠ±æ‹¬å·ä¹‹é—´çš„éƒ¨åˆ†ï¼Œè¢«ç§°ä¸ºç»“æž„ä½“ã€‚åœ¨ç»“æž„ä½“å†…å¯ä»¥å£°æ˜Žè¿™ä¸ªç»“æž„çš„æˆå‘˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å£°æ˜Žäº†ä¸¤ä¸ªç±»åž‹ä¸ºf32çš„æˆå‘˜â€”â€”xå’Œyã€‚

æœ‰äº†ç»“æž„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒç”¨èµ·æ¥ã€‚

```zig {3}
const std = @import("std");
pub fn main() void {
    const point = Point{
        .x = 1.0,
        .y = 1.80086,
    };

    std.debug.print("We got a point ({}, {}).\n", .{ point.x, point.y });
}
```

```ansi
$stdout returns nothing.
$stderr:
We got a point (1e0, 1.80086e0).
```

æœ‰ä¸¤ä¸ªç‚¹éœ€è¦è§£é‡Šä¸€ä¸‹ã€‚

é¦–å…ˆï¼Œåœ¨ç¬¬3è¡Œï¼Œæˆ‘ä»¬å£°æ˜Žäº†ä¸€ä¸ªpointå˜é‡ï¼Œç„¶åŽåˆå§‹åŒ–äº†ä¸€ä¸ªPointç»“æž„å¹¶èµ‹å€¼ç»™å®ƒã€‚åˆå§‹åŒ–è¯­å¥ä¹Ÿå’ŒCé‡Œé¢éžå¸¸ç›¸ä¼¼ã€‚

å…¶æ¬¡ï¼Œæˆ‘ä»¬æ‰“å°äº†pointé‡Œå­˜å‚¨çš„å€¼ã€‚è¿™é‡Œçš„`point.x`å’Œ`point.y`åˆ†åˆ«è®¿é—®äº†ä¸¤ä¸ªæˆå‘˜ï¼Œ`.`å«ä½œæˆå‘˜è®¿é—®è¿ç®—ç¬¦ã€‚

## æ•°ç»„

æ•°ç»„ï¼ˆArrayï¼‰æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æž„ï¼Œå®ƒç”±ç›¸åŒç±»åž‹çš„æ•°æ®å…ƒç´ ç»„æˆï¼Œè¿™äº›å…ƒç´ å­˜å‚¨åœ¨è¿žç»­çš„åŒºåŸŸå†…ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡ä¸‹æ ‡è¿›è¡Œè®¿é—®ã€‚

ä¸‹é¢çš„å›¾ç‰‡æ˜¯ä¸€ä¸ªæ•°ç»„ç¤ºä¾‹ï¼Œè¿™ä¸ªæ•°ç»„ä¸­å­˜å‚¨äº†5ä¸ªç±»åž‹ä¸ºi8çš„æ•´åž‹æ•°å­—ï¼Œå› æ­¤é•¿åº¦ä¸º5ã€‚åŒæ—¶ï¼Œç®­å¤´æŒ‡å‘äº†ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ çš„ä¸‹æ ‡æ˜¯0ã€‚

![æ•°ç»„ç¤ºä¾‹](./imgs/02/0201_Array.png)

æˆ‘ä»¬å·²ç»è§è¿‡åœ¨Zigæ€Žä¹ˆåˆ›å»ºå’Œè®¿é—®ä¸€æ ·çš„æ•°ç»„ï¼š

```zig
const number = [5]i8{ 2, -1, 5, 6, 3 };
for (number, 0..) |value, i| {
    std.debug.print("Index={}, Value={}\n", .{ i, value });
}
std.debug.print("number.len={}\n", .{number.len});
```

```ansi
$stdout returns nothing.
$stderr:
Index=0, Value=2
Index=1, Value=-1
Index=2, Value=5
Index=3, Value=6
Index=4, Value=3
number.len=5
```

åœ¨å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ•°ç»„çš„é•¿åº¦éƒ½æ˜¯å›ºå®šçš„ï¼Œå¿…é¡»è¦ç¼–è¯‘çš„æ—¶å€™å°±ç¡®å®šé•¿åº¦ã€‚

## å˜é•¿çš„æ•°ç»„ â€”â€” åˆ—è¡¨

å¦‚æžœæˆ‘ä»¬æƒ³è¦åŠ¨æ€åœ°è°ƒæ•´æ•°ç»„é•¿åº¦å‘¢ï¼Ÿåœ¨Pythonä¸­ï¼Œå¸¸ç”¨çš„åˆ—è¡¨å¯ä»¥è‡ªåŠ¨è°ƒæ•´é•¿åº¦ï¼›åœ¨Rustä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‘é‡Vecã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨**åˆ—è¡¨**è¿™ä¸ªç§°å‘¼ï¼Œå°†æˆ‘ä»¬å®žçŽ°çš„ç‰ˆæœ¬å‘½åä¸ºSimpleArrayListã€‚

::: tip
Zigè¯­è¨€çš„æ ‡å‡†åº“æä¾›äº†ä¸€ä¸ªåˆ—è¡¨çš„å®žçŽ°[std.ArrayList](https://ziglang.org/documentation/master/std/#std.ArrayList)ï¼Œæˆ‘ä»¬è·Ÿéšæ ‡å‡†åº“ç§°ä¹‹ä¸ºåˆ—è¡¨ï¼ˆListï¼‰ã€‚
:::

æ­£å¦‚å…¶åï¼ŒSimpleArrayListä½¿ç”¨æ™®é€šçš„æ•°ç»„å­˜å‚¨æ•°æ®ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å­˜å‚¨äº†å¤šå°‘ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”éœ€è¦èƒ½åœ¨éœ€è¦æ—¶æ‰©å¤§å†…éƒ¨å­˜å‚¨ç”¨çš„æ•°ç»„ã€‚ç”±æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸‹é¢çš„åŸºæœ¬çš„å®šä¹‰ï¼š

```zig
const SimpleArrayList = struct {
    allocator: std.mem.Allocator,   // å†…å­˜åˆ†é…å™¨ï¼Œç”¨äºŽåŠ¨æ€åˆ†é…å†…å­˜
    items: []???,                  // åˆ—è¡¨å†…å…ƒç´ 
    len: usize,                     // åˆ—è¡¨å†…å…ƒç´ çš„æ•°é‡
};
```

### å®žçŽ°**æ³›åž‹**

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œ`items`åº”è¯¥æ˜¯ä»€ä¹ˆç±»åž‹çš„å‘¢ï¼Ÿä¸ºäº†èƒ½ä½¿åˆ—è¡¨é€‚ç”¨äºŽä¸åŒç±»åž‹çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦**æ³›åž‹**ã€‚ç®€å•æ¥è¯´ï¼Œæ³›åž‹å°±æ˜¯é€šè¿‡æŸç§æ–¹å¼ï¼Œä½¿å¾—å‡½æ•°æˆ–æ˜¯ç»“æž„ä½“å¯ä»¥æŽ¥æ”¶ä¸åŒçš„ç±»åž‹ä½œä¸ºå‚æ•°æˆ–æˆå‘˜ã€‚

æˆ‘ä»¬å‰é¢è¯´è¿‡ï¼Œåœ¨Zigä¸­ç±»åž‹æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥å°†ç±»åž‹ä½œä¸ºå‚æ•°ä¼ ç»™å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºè¿”å›žå€¼è¿”å›žã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼å®žçŽ°æ³›åž‹ã€‚æˆ‘ä»¬å¯ä»¥å£°æ˜Žä¸€ä¸ªå‡½æ•°ï¼ŒæŽ¥æ”¶ä¸€ä¸ªç±»åž‹Tï¼Œç„¶åŽè¿”å›žå­˜å‚¨ç±»åž‹Tçš„å…ƒç´ çš„åˆ—è¡¨ã€‚

```zig
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,
    };
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬é‡åˆ°äº†å‡ ä¸ªæ²¡è§è¿‡çš„ä¸œè¥¿ï¼š

1. å…³é”®è¯`comptime`ï¼šè¿™æ˜¯Zigçš„ä¸€ä¸ªé‡è¦å±žæ€§ï¼Œå®ƒæœ‰å¾ˆå¤šç”¨å¤„ï¼Œåœ¨è¿™é‡Œï¼Œå®ƒæ„å‘³ç€Tæ˜¯ä¸€ä¸ªåœ¨ç¼–è¯‘çš„æ—¶å€™å°±å·²çŸ¥çš„å€¼ï¼›
2. ç±»åž‹`type`ï¼šè¿™ä¸ªç±»åž‹æ˜¯â€œç±»åž‹çš„ç±»åž‹â€ï¼›

é€šè¿‡è¿™ç§æ–¹å¼è¿”å›žçš„ç»“æž„ä½“çš„åå­—æ¯”è¾ƒå¤æ‚ï¼Œä¸æ–¹ä¾¿ä½¿ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨Zigçš„å†…å»ºå‡½æ•°æ¥æž„å»ºä¸€ä¸ªåˆ«åæ¥ã€‚

```zig {3}
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,
    };
}
```

åœ¨ç¬¬3è¡Œä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨`@This()`å‡½æ•°èŽ·å¾—äº†å½“å‰ç»“æž„çš„ç±»åž‹ã€‚

::: tip
åœ¨æ‰€æœ‰å†…å»ºå‡½æ•°ä¸­ï¼Œä»¥å¤§å†™å­—æ¯å¼€å¤´çš„å‡½æ•°éƒ½è¿”å›ž`type`ç±»åž‹çš„å€¼ï¼Œä¾‹å¦‚è¿™é‡Œçš„`@This()`ã€‚

è¿™é‡Œçš„æˆå‘˜è¢«å‘½åä¸º`This`ï¼Œä½†è¿™ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œç”¨ä½ å–œæ¬¢çš„å°±è¡Œã€‚
:::

### åˆå§‹åŒ–å’Œååˆå§‹åŒ–

è®©æˆ‘ä»¬æ‰¾ä¸€ä¸ªåœ°æ–¹æ¥åˆå§‹åŒ–æ•°æ®ç»“æž„ã€‚

æŒ‰ç…§çº¦å®šä¿—æˆï¼Œä¸€èˆ¬å£°æ˜Žä¸€ä¸ªåä¸º`init`çš„å‡½æ•°ä½œä¸ºåˆå§‹åŒ–å‡½æ•°ï¼Œä¸€ä¸ªåä¸º`deinit`çš„å‡½æ•°ä½œä¸ºååˆå§‹åŒ–å‡½æ•°ã€‚

å‡½æ•°åº”è¯¥æ”¾åœ¨å“ªé‡Œå‘¢ï¼Ÿåœ¨Cä¸­ï¼Œæˆ‘ä»¬æŠŠæˆå‘˜å®šä¹‰åœ¨ç»“æž„ä½“å†…ï¼Œç„¶åŽåœ¨ç»“æž„ä½“å¤–ç”¨ä¸€ä¸ªå¾ˆé•¿çš„å‰ç¼€æ¥åŒºåˆ†ï¼Œæ¯”å¦‚ï¼š

```c
typedef struct {
    int *items;
    int len;
} SimpleArrayListInt;

void simple_array_list_int_init(SimpleArrayListInt*);
```

åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬ä¼šç›´æŽ¥åœ¨ç±»çš„å®šä¹‰å†…å®šä¹‰ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ï¼Œæ¯”å¦‚ï¼š

```python
class SimpleArrayInit():
    def __init__(self):
        pass
```

åœ¨Zigä¸­ï¼Œæˆ‘ä»¬ç»“åˆè¿™ä¸¤ç§å½¢å¼ï¼šåœ¨ç»“æž„ä½“å†…å£°æ˜Žå‡½æ•°ï¼Œæ¯”å¦‚ï¼š

```zig {9}
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const DefaultCapacity: usize = 10;
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .items = try allocator.alloc(T, This.DefaultCapacity),
                .len = 0,
            };
        }
    };
}
```

é™¤äº†`init`ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå¯¹åº”çš„`deinit`ï¼Œä»¥ä¾¿åœ¨éœ€è¦çš„æ—¶å€™é‡Šæ”¾ç”³è¯·çš„å†…å­˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦é‡Šæ”¾`items`è¿™ä¸ªæˆå‘˜ã€‚

```zig
        pub fn deinit(self: This) void {
            self.allocator.free(self.items);
        }
```

ç»„è£…èµ·æ¥ï¼Œæˆ‘ä»¬å°±æœ‰äº†ä¸€ä¸ªSimpleArrayListçš„åŸºæœ¬æ¡†æž¶ï¼š

```zig
const std = @import("std");

pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const DefaultCapacity: usize = 10;
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .items = try allocator.alloc(T, This.DefaultCapacity),
                .len = 0,
            };
        }

        pub fn deinit(self: This) void {
            self.allocator.free(self.items);
        }
    };
}

pub fn main() !void {
    const a = try SimpleArrayList(i8).init(std.heap.page_allocator);
    defer a.deinit();
    std.debug.print("{} of {}\n", .{ a.len, a.items.len });
}
```

```ansi
$stdout returns nothing.
$stderr:
0 of 10
```

ä»Žè¿è¡Œç»“æžœæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬æˆåŠŸåœ°åˆ†é…äº†10ä¸ªå…ƒç´ çš„ç©ºé—´ï¼Œä¸è¿‡æš‚æ—¶è¿˜æ²¡æœ‰å­˜å‚¨ä»»ä½•å…ƒç´ è¿›åŽ»ã€‚

::: tip
å¦å¤–ï¼Œè¿™é‡Œæˆ‘ä»¬åˆé‡è§äº†ä¸€ä¸ªä¸è®¤è¯†çš„å…³é”®è¯â€”â€”`defer`ã€‚å¦‚æžœä½ æœ‰Goè¯­è¨€çš„ä½¿ç”¨ç»éªŒï¼Œè¿™å¯èƒ½ä¼šå¾ˆçœ¼ç†Ÿã€‚åœ¨deferå…³é”®è¯åŽçš„è¯­å¥ä¼šåœ¨å½“å‰ä½œç”¨åŸŸç»“æŸæ—¶è¢«æ‰§è¡Œã€‚ä¸ä¸¥è°¨åœ°è¯´ï¼Œä¼šåœ¨ä¸‹ä¸€ä¸ªèŠ±æ‹¬å·åŽæ‰§è¡Œã€‚ä¸‹é¢çš„ä¾‹å­å¯ä»¥è¯´æ˜Žä¸åŒçš„æ‰§è¡Œé¡ºåºã€‚
```zig
const std = @import("std");
const print = std.debug.print;

pub fn main() void {
    print("1\n", .{});  // æ‰“å°1
    defer print("2\n", .{});

    {
        defer print("3\n", .{});
        print("4\n", .{});  // æ‰“å°4
        {
            defer print("5\n", .{});
            print("6\n", .{});  // æ‰“å°6
        }   // æ‰“å°5
    }   // æ‰“å°3

}   // æ‰“å°2
```

```ansi
$stdout returns nothing.
$stderr:
1
4
6
5
3
2
```

:::

::: warning
æˆ‘ä»¬åº”è¯¥åœ¨ä¸éœ€è¦ä¸€å—å†…å­˜åŽå°½å¯èƒ½åœ°é‡Šæ”¾æŽ‰å®ƒï¼Œä»¥ä¾¿å‡è½»ç®¡ç†å†…å­˜çš„å¤æ‚åº¦ã€‚

å¤§é‡åˆ†é…å†…å­˜è€Œä¸é‡Šæ”¾ä¼šå¯¼è‡´**å†…å­˜æ³„æ¼**ï¼Œé€ æˆèµ„æºæµªè´¹ã€‚
:::

æˆ‘ä»¬è¿˜éœ€è¦ä»€ä¹ˆå‡½æ•°å‘¢ï¼Ÿæˆ‘ä»¬æƒ³è¦èŽ·å–æŸä¸ªä¸‹æ ‡å¤„çš„å…ƒç´ ï¼Œæƒ³è¦ä¿®æ”¹æŸä¸ªä¸‹æ ‡å¤„çš„å…ƒç´ ï¼Œæƒ³è¦æ’å…¥æ–°çš„å…ƒç´ ï¼Œæƒ³è¦åœ¨åˆ—è¡¨æœ«å°¾æ·»åŠ æ–°çš„å…ƒç´ ã€‚æ€»ç»“ä¸€ä¸‹ï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦ä¸‹é¢çš„å››ä¸ªå‡½æ•°ï¼š

1. nth(n)ï¼šè®¿é—®ä¸‹æ ‡ä¸ºnçš„å…ƒç´ ï¼›
2. setNth(n, v)ï¼šå°†ä¸‹æ ‡ä¸ºnçš„å…ƒç´ è®¾ç½®ä¸ºvï¼›
3. insertNth(n, v)ï¼šåœ¨ä¸‹æ ‡nå¤„æ’å…¥å…ƒç´ vï¼›
4. append(v)ï¼šåœ¨åˆ—è¡¨æœ«å°¾è¿½åŠ å…ƒç´ vï¼›

æˆ‘ä»¬ä»Ž`nth`å¼€å§‹å§ã€‚

### nth

æœ€ç¬¦åˆç›´è§‰çš„ï¼Œæˆ‘ä»¬ä»Ž`items`æˆå‘˜ä¸­å–å‡ºä¸€ä¸ªå…ƒç´ ï¼š

```zig
pub fn nth(self: This, n: usize) T {
    return self.items[n];
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ³¨æ„åˆ°ä¸€ä¸ªæ–°çš„æ¦‚å¿µâ€”â€”selfã€‚å¦‚æžœä½ æœ‰ä½¿ç”¨Pythonçš„ç»éªŒï¼Œä½ åº”è¯¥ä¼šè§‰å¾—çœ¼ç†Ÿã€‚è¿™é‡Œçš„selfæŒ‡çš„æ˜¯è¢«æˆå‘˜è®¿é—®è¿ç®—ç¬¦`.`è®¿é—®çš„å¯¹è±¡ï¼Œæ¯”å¦‚è¯´å¦‚æžœæˆ‘ä»¬è°ƒç”¨`list.nth(1)`ï¼Œé‚£ä¹ˆè¿™é‡Œçš„selfå°±æ˜¯listã€‚

selfä¹Ÿå¯ä»¥å«å…¶ä»–åå­—ï¼Œåªè¦ä»–æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°å°±è¡Œã€‚å½“ç»“æž„ä½“å†…çš„æŸä¸ªå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºselfï¼ˆä¹Ÿå¯ä»¥å«å…¶ä»–åå­—ï¼‰æ—¶ï¼Œæˆ‘ä»¬ç§°å®ƒä¸ºä¸€ä¸ª**æ–¹æ³•**ã€‚

å¦‚æžœæˆ‘ä»¬éœ€è¦ä¿®æ”¹selfçš„å†…å®¹çš„è¯ï¼Œä¹Ÿå¯ä»¥ä¼ å…¥æŒ‡é’ˆä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ã€‚

ä¸Šé¢çš„å®žçŽ°æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜ï¼š`n`è¿™ä¸ªä½ç½®ä¸Šä¸ä¸€å®šæœ‰å…ƒç´ ï¼Œ`items`ä¹Ÿä¸ä¸€å®šæœ‰è¿™ä¹ˆå¤§ï¼Œè¿™ä¼šé€ æˆè¢«ç§°ä¸º**ä¸‹æ ‡è¶Šç•Œ**çš„é—®é¢˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯¹ä¸‹æ ‡nè¿›è¡Œæ£€æŸ¥ï¼Œå¦‚æžœè¶…å‡ºè¾¹ç•Œå°±è¿”å›žé”™è¯¯ï¼Œå¦‚æžœæ­£å¸¸è®¿é—®åˆ™è¿”å›žå…ƒç´ ã€‚æ²¡é”™ï¼Œæˆ‘ä»¬å°†ä¼šç”¨åˆ°é”™è¯¯è”åˆç±»åž‹ã€‚

```zig
pub fn nth(self: This, n: usize) !T {
    if (n >= self.len) {
        return error.IndexOutOfBound;
    }
    return self.items[n];
}
```

å› ä¸ºnæ˜¯usizeç±»åž‹ï¼Œæ‰€ä»¥å®ƒä¸ä¼šå°äºŽ0ï¼›`self.len`ä¸€å®šå°äºŽç­‰äºŽ`self.items.len`ï¼Œæ‰€ä»¥åªè¦nå¤§äºŽself.lenï¼Œå°±æ²¡æœ‰å¿…è¦åˆ¤æ–­æ˜¯å¦å¤§äºŽself.items.lenï¼Œä¸€å®šæ˜¯ä¸‹æ ‡è¶Šç•Œã€‚

### setNth

ç±»ä¼¼äºŽ`nth`ï¼Œ`setNth`ä¹Ÿè¦æ£€æŸ¥è¾¹ç•Œã€‚å½“å‘ç”Ÿä¸‹æ ‡è¶Šç•Œæ—¶ï¼Œæˆ‘ä»¬è¿”å›žä¸€æ ·çš„é”™è¯¯ï¼›å½“æ²¡æœ‰å‘ç”Ÿé”™è¯¯æ—¶ï¼Œæˆ‘ä»¬è¿”å›žvoidã€‚

```zig
pub fn setNth(self: *This, n: usize, v: T) !void {
    if (n >= self.len) {
        return error.IndexOutOfBound;
    }
    self.items[n] = v;
}
```

æ­£å¦‚å‰æ–‡æ‰€è¨€ï¼Œæ­¤å¤„æˆ‘ä»¬éœ€è¦ä¿®æ”¹åˆ—è¡¨ï¼Œå› æ­¤æˆ‘ä»¬ä¼ å…¥çš„å‚æ•°ç±»åž‹ä¸ºæŒ‡é’ˆã€‚

::: warning
å‡è®¾ä½ æœ‰ä¸€ä¸ªåˆ—è¡¨çš„å®žä¾‹`a`ï¼Œä½ å¸Œæœ›é€šè¿‡`setNth`æ¥è®¾ç½®å…ƒç´ ï¼Œé‚£ä¹ˆä½ å¿…é¡»å£°æ˜Žaä¸ºä¸€ä¸ªå¯å˜é‡ï¼Œä¹Ÿå°±æ˜¯å¿…é¡»é€šè¿‡`var`å…³é”®è¯å£°æ˜Žè¿™ä¸ªå˜é‡ï¼š

```zig
var a = try SimpleArrayList(i8).init(std.heap.page_allocator);
defer a.deinit();
std.debug.print("{!}\n", .{a.setNth(10, 8)});
```

å¦‚æžœä½ ä½¿ç”¨`const`å£°æ˜Žäº†ä¸€ä¸ªä¸å¯å˜é‡ï¼Œç¼–è¯‘å™¨å°†ä¼šæŠ¥é”™ã€‚

```zig
// error: expected type '*02_array.SimpleArrayList(i8)', found '*const 02_array.SimpleArrayList(i8)'
const a = try SimpleArrayList(i8).init(std.heap.page_allocator);
defer a.deinit();
std.debug.print("{!}\n", .{a.setNth(10, 8)});
```
:::

### append

åœ¨å®žçŽ°`insertNth`ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå®žçŽ°ç›¸å¯¹ç®€å•çš„`append`ã€‚

æˆ‘ä»¬çš„åŸºæœ¬è¯‰æ±‚æ˜¯åœ¨åˆ—è¡¨çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œæœ€ç®€åŒ–çš„å®žçŽ°å¦‚ä¸‹ï¼š

```zig
pub fn append(self: *This, v: T) void {
    self.items[self.len] = v;
    self.len += 1;
}
```

æˆ‘ä»¬ä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼šåœ¨`init`å‡½æ•°é‡Œï¼Œæˆ‘ä»¬åªç»™`items`åˆ†é…äº†10ä¸ªå…ƒç´ çš„ç©ºé—´ï¼Œå¦‚æžœæˆ‘ä»¬é€šè¿‡ä¸Šé¢çš„è¿™ä¸ª`append`æ·»åŠ äº†11ä¸ªå…ƒç´ ï¼Œå°±ä¼šè¶…å‡ºitemsçš„èŒƒå›´ï¼Œé‡åˆ°ä¸‹æ ‡è¶Šç•Œã€‚è¿™è¯¥æ€Žä¹ˆåŠžï¼Ÿæˆ‘ä»¬åªéœ€è¦åœ¨æ·»åŠ å…ƒç´ å‰ï¼Œåˆ¤æ–­ç©ºé—´æ˜¯å¦è¶³å¤Ÿï¼Œå¦‚æžœä¸å¤Ÿå°±æ‰©å®¹ã€‚è¿™æ ·ï¼Œå°±ä¸ä¼šå‡ºçŽ°ç©ºé—´ä¸è¶³çš„é—®é¢˜ã€‚æˆ‘ä»¬å¢žåŠ ä¸€ä¸ªæ–°çš„æ–¹æ³•`enlarge`æ¥å¢žå¤§ç©ºé—´ã€‚

#### enlarge

è¿™ä¸ªæ–¹æ³•çš„åŸºæœ¬æµç¨‹ä¸ºï¼š

1. åˆ†é…æ›´å¤§çš„ç©ºé—´ï¼›
2. å¤åˆ¶å…ƒç´ åˆ°æ–°çš„ç©ºé—´ä¸­ï¼›
3. é‡Šæ”¾åŽŸæ¥çš„ç©ºé—´ï¼›

ä¸€ä¸ªç®€å•çš„å®žçŽ°å¦‚ä¸‹ï¼š

```zig
pub fn enlarge(self: *This) !void {
    // è®¡ç®—â€œæ›´å¤§çš„ç©ºé—´â€æœ‰å¤šå¤§
    // å› ä¸ºZigä¸ä¼šè¿›è¡Œä¸å®‰å…¨çš„éšå¼ç±»åž‹è½¬æ¢ï¼Œä¸ºäº†è®©usizeç±»åž‹çš„self.items.lenå’Œ1.5ç›¸ä¹˜ï¼Œæˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨è¿›è¡Œè½¬æ¢
    const new_capacity: usize = @intFromFloat(@as(f32, @floatFromInt(self.items.len)) * @as(f32, 1.5));
    // 1. åˆ†é…æ›´å¤§çš„ç©ºé—´
    const new_items = try self.allocator.alloc(T, new_capacity);
    // 2. å¤åˆ¶å…ƒç´ åˆ°æ–°ç©ºé—´ä¸­
    std.mem.copyForwards(T, new_items, self.items);
    // 3. é‡Šæ”¾åŽŸæ¥çš„ç©ºé—´
    self.allocator.free(self.items);
    self.items = new_items;
}
```

æˆ‘ä»¬å°†ä»£ç æ®µå¯¹åº”çš„æ­¥éª¤å†™åœ¨äº†æ³¨é‡Šä¸­ã€‚

æœ‰äº†enlargeï¼Œæˆ‘ä»¬ç»ˆäºŽå¯ä»¥å®žçŽ°appendäº†ã€‚

#### append

appendçš„åŸºæœ¬æ­¥éª¤ä¸ºï¼š

1. åˆ¤æ–­ç©ºé—´æ˜¯å¦å……è¶³ï¼Œæ˜¯åˆ™åˆ°æ­¥éª¤3ï¼Œå¦åˆ™åˆ°æ­¥éª¤2ï¼›
2. ä½¿ç”¨enlargeæ–¹æ³•æ‰©å¤§ç©ºé—´ï¼›
3. åœ¨æœ«å°¾å¢žåŠ å…ƒç´ ï¼›

```zig
pub fn append(self: *This, v: T) !void {
    // 1. åˆ¤æ–­å¤§å°
    if (self.len >= self.items.len) {
        // 2. æ‰©å¤§ç©ºé—´
        try self.enlarge();
    }
    // å¢žåŠ å…ƒç´ 
    self.items[self.len] = v;
    self.len += 1;
}
```
### insertNth

ðŸš§æ–½å·¥ä¸­ðŸš§


# ArrayList åˆ—è¡¨

## å†…å­˜æ˜¯ä¸€ç§èµ„æº

Zigä¸ä¼šä»£æ›¿ç¨‹åºå‘˜ç®¡ç†å†…å­˜ï¼Œå› æ­¤ï¼Œä½¿ç”¨Zigè¿›è¡Œç¼–ç¨‹çš„äººå¿…é¡»çŸ¥é“æ€Žä¹ˆç®¡ç†å†…å­˜ã€‚

å½“ç„¶ï¼Œå°±æˆ‘ä»¬çš„ä¸»é¢˜è€Œè¨€ï¼Œä½ å¹¶ä¸éœ€è¦éžå¸¸ç†Ÿæ‚‰æ€Žä¹ˆè¿›è¡Œç®¡ç†ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šåœ¨è¿™æ–¹é¢æ·±å…¥å¤ªå¤šã€‚

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åªä»‹ç»ä¸€ç§ç®€å•çš„å†…å­˜ç®¡ç†æ–¹å¼ï¼Œæœ‰å…³å†…å­˜çš„è¯¦ç»†å¯è§[è¿™ä¸ªç½‘ç«™](https://ziglang.org/documentation/master/#Memory)ã€‚

### ArenaAllocator

åœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬å®žçŽ°çš„æ•°æ®ç»“æž„å¹¶ä¸ä¼šè¢«æŠ•å…¥åˆ°å®žé™…çš„ç”Ÿäº§å¼€å‘ä¸­ï¼ˆæˆ‘ä¸å»ºè®®è¿™ä¹ˆåšï¼‰ï¼Œæ‰€æœ‰çš„æ•°æ®ç»“æž„çš„å®žä¾‹éƒ½åªä¼šå­˜åœ¨å¾ˆçŸ­çš„ä¸€æ®µæ—¶é—´ï¼Œå› æ­¤ï¼Œå®Œå…¨å¯ä»¥ä½¿ç”¨ArenaAllocatoræ¥åˆ†é…å†…å­˜ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€æ¬¡æ€§æ–½æ”¾ç”³è¯·çš„æ‰€æœ‰å†…å­˜ã€‚å¦‚æžœä½ æƒ³çŸ¥é“ArenaAllocatoræ˜¯æ€Žä¹ˆå·¥ä½œçš„ï¼Œå¯ä»¥æŸ¥çœ‹[è¿™ä¸ªç½‘ç«™](https://www.huy.rocks/everyday/01-12-2022-zig-how-arenaallocator-works)ã€‚

è®©æˆ‘ä»¬æ¥åˆ†é…ç‚¹ä¸œè¥¿å§ï¼

```zig
var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
const allocator = arena.allocator();
const a_number = try allocator.create(u32);
a_number.* = 100;
std.debug.print("We allocated {p} which stores {d}!\n", .{ a_number, a_number.* });
arena.deinit();
```

```ansi
$stdout returns nothing.
$stderr:
We allocated u32@151ed1796010 which stores 100!
```

è®©æˆ‘ä»¬æ¥é€è¡Œçœ‹çœ‹æœ‰ä»€ä¹ˆå§ï¼

1. `var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);`ï¼šé€šè¿‡ä¼ å…¥ä¸€ä¸ªå…¶ä»–çš„Allocatorï¼Œæˆ‘ä»¬åˆå§‹åŒ–äº†ä¸€ä¸ªArenaAllocatorã€‚ArenaAllocatorä¼šç”¨è¿™ä¸ªåˆ†é…å™¨æ¥å®žé™…åˆ†é…å†…å­˜ï¼›
2. `const allocator = arena.allocator();`ï¼šæˆ‘ä»¬ä»Žarenaä¸­è¦äº†ä¸€ä¸ªAllocatorï¼Œè¿™æ˜¯æˆ‘ä»¬ç”¨å®ƒæ¥åˆ†é…å†…å­˜ï¼›
3. `const a_number = try allocator.create(u32);`ï¼šæˆ‘ä»¬ä»Žå†…å­˜ä¸­è¦æ¥äº†ä¸€å—èƒ½æ”¾ä¸‹u32ç±»åž‹çš„ç©ºé—´ï¼Œcreateå‡½æ•°è¿”å›žçš„æ˜¯ä¸€ä¸ªé”™è¯¯è”åˆç±»åž‹ï¼Œé€šè¿‡tryæˆ‘ä»¬æ‹¿å‡ºäº†å®žé™…çš„å€¼â€”â€”ä¸€ä¸ªæŒ‡å‘åˆ†é…çš„å†…å­˜åŒºåŸŸçš„æŒ‡é’ˆã€‚å¦‚æžœä½ å¿˜äº†é”™è¯¯è”åˆç±»åž‹ï¼Œå¯ä»¥çœ‹çœ‹[ä¸Šä¸€ç« ](./01_zig_basics)ã€‚
4. `a_number.* = 100;`ï¼šæˆ‘ä»¬å‘åˆšæ‰åˆ†é…çš„å†…å­˜å†™äº†100è¿™ä¸ªæ•°å­—ï¼›
5. `std.debug.print("We allocated {p} which stores {d}!\n", .{ a_number, a_number.* });`ï¼š æ‰“å°å®ƒï¼
6. `arena.deinit();`ï¼šå½“æˆ‘ä»¬ä¸å†ä½¿ç”¨arenaåŽï¼Œä¸€å®šè¦ååˆå§‹åŒ–ï¼ˆdeinitï¼‰å®ƒï¼Œæ¥æ–½æ”¾æ‰€æœ‰çš„å†…å­˜ã€‚

åœ¨åŽé¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ç»å¸¸è§åˆ°ç±»ä¼¼çš„ç‰‡æ®µã€‚

## ç»“æž„ä½“

ä¸ºäº†å®žçŽ°ä¸€ç§æ•°æ®ç»“æž„ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåœ°æ–¹å­˜å‚¨æ•°æ®ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æœ‰â€œç»“æž„â€ã€‚

å¦‚æžœä½ æœ‰ä½¿ç”¨Cçš„ç»éªŒï¼Œä½ åº”è¯¥å¯¹ä¸‹é¢çš„ä»£ç ä¸ä¼šé™Œç”Ÿï¼š

```zig
const Point = struct {
    // ç»“æž„ä½“
    x: f32, // æˆå‘˜
    y: f32, // æˆå‘˜
};
```

å¦‚æžœä½ è§‰å¾—é™Œç”Ÿä¹Ÿæ²¡å…³ç³»ï¼Œæˆ‘ä»¬æ…¢æ…¢è§£é‡Šã€‚

é¦–å…ˆï¼Œåœ¨`const Point = struc {};`è¿™é‡Œæˆ‘ä»¬å£°æ˜Žäº†ä¸€ä¸ªåä¸ºPointçš„å˜é‡ï¼Œå¹¶ä¸ºå…¶èµ‹å€¼ä¸ºä¸€ä¸ªç»“æž„ä½“ã€‚åœ¨Zigä¸­ï¼Œç±»åž‹æ˜¯â€œä¸€ç­‰å…¬æ°‘â€ï¼Œå®ƒå¯ä»¥åƒå€¼ã€æŒ‡é’ˆä¸€æ ·è¢«èµ‹äºˆå˜é‡ã€‚

åœ¨ä¸¤ä¸ªèŠ±æ‹¬å·ä¹‹é—´çš„éƒ¨åˆ†ï¼Œè¢«ç§°ä¸ºç»“æž„ä½“ã€‚åœ¨ç»“æž„ä½“å†…å¯ä»¥å£°æ˜Žè¿™ä¸ªç»“æž„çš„æˆå‘˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å£°æ˜Žäº†ä¸¤ä¸ªç±»åž‹ä¸ºf32çš„æˆå‘˜â€”â€”xå’Œyã€‚

æœ‰äº†ç»“æž„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒç”¨èµ·æ¥ã€‚

```zig {3}
const std = @import("std");
pub fn main() void {
    const point = Point{
        .x = 1.0,
        .y = 1.80086,
    };

    std.debug.print("We got a point ({}, {}).\n", .{ point.x, point.y });
}
```

```ansi
$stdout returns nothing.
$stderr:
We got a point (1e0, 1.80086e0).
```

æœ‰ä¸¤ä¸ªç‚¹éœ€è¦è§£é‡Šä¸€ä¸‹ã€‚

é¦–å…ˆï¼Œåœ¨ç¬¬3è¡Œï¼Œæˆ‘ä»¬å£°æ˜Žäº†ä¸€ä¸ªpointå˜é‡ï¼Œç„¶åŽåˆå§‹åŒ–äº†ä¸€ä¸ªPointç»“æž„å¹¶èµ‹å€¼ç»™å®ƒã€‚åˆå§‹åŒ–è¯­å¥ä¹Ÿå’ŒCé‡Œé¢éžå¸¸ç›¸ä¼¼ã€‚

å…¶æ¬¡ï¼Œæˆ‘ä»¬æ‰“å°äº†pointé‡Œå­˜å‚¨çš„å€¼ã€‚è¿™é‡Œçš„`point.x`å’Œ`point.y`åˆ†åˆ«è®¿é—®äº†ä¸¤ä¸ªæˆå‘˜ï¼Œ`.`å«ä½œæˆå‘˜è®¿é—®è¿ç®—ç¬¦ã€‚

## æ•°ç»„

æ•°ç»„ï¼ˆArrayï¼‰æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æž„ï¼Œå®ƒç”±ç›¸åŒç±»åž‹çš„æ•°æ®å…ƒç´ ç»„æˆï¼Œè¿™äº›å…ƒç´ å­˜å‚¨åœ¨è¿žç»­çš„åŒºåŸŸå†…ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡ä¸‹æ ‡è¿›è¡Œè®¿é—®ã€‚

ä¸‹é¢çš„å›¾ç‰‡æ˜¯ä¸€ä¸ªæ•°ç»„ç¤ºä¾‹ï¼Œè¿™ä¸ªæ•°ç»„ä¸­å­˜å‚¨äº†5ä¸ªç±»åž‹ä¸ºi8çš„æ•´åž‹æ•°å­—ï¼Œå› æ­¤é•¿åº¦ä¸º5ã€‚åŒæ—¶ï¼Œç®­å¤´æŒ‡å‘äº†ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ çš„ä¸‹æ ‡æ˜¯0ã€‚

![æ•°ç»„ç¤ºä¾‹](./imgs/02/0201_Array.png)

æˆ‘ä»¬å·²ç»è§è¿‡åœ¨Zigæ€Žä¹ˆåˆ›å»ºå’Œè®¿é—®ä¸€æ ·çš„æ•°ç»„ï¼š

```zig
const number = [5]i8{ 2, -1, 5, 6, 3 };
for (number, 0..) |value, i| {
    std.debug.print("Index={}, Value={}\n", .{ i, value });
}
std.debug.print("number.len={}\n", .{number.len});
```

```ansi
$stdout returns nothing.
$stderr:
Index=0, Value=2
Index=1, Value=-1
Index=2, Value=5
Index=3, Value=6
Index=4, Value=3
number.len=5
```

åœ¨å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ•°ç»„çš„é•¿åº¦éƒ½æ˜¯å›ºå®šçš„ï¼Œå¿…é¡»è¦ç¼–è¯‘çš„æ—¶å€™å°±ç¡®å®šé•¿åº¦ã€‚

## å˜é•¿çš„æ•°ç»„ â€”â€” åˆ—è¡¨

å¦‚æžœæˆ‘ä»¬æƒ³è¦åŠ¨æ€åœ°è°ƒæ•´æ•°ç»„é•¿åº¦å‘¢ï¼Ÿåœ¨Pythonä¸­ï¼Œå¸¸ç”¨çš„åˆ—è¡¨å¯ä»¥è‡ªåŠ¨è°ƒæ•´é•¿åº¦ï¼›åœ¨Rustä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‘é‡Vecã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨**åˆ—è¡¨**è¿™ä¸ªç§°å‘¼ï¼Œå°†æˆ‘ä»¬å®žçŽ°çš„ç‰ˆæœ¬å‘½åä¸ºSimpleArrayListã€‚

::: tip
Zigè¯­è¨€çš„æ ‡å‡†åº“æä¾›äº†ä¸€ä¸ªåˆ—è¡¨çš„å®žçŽ°[std.ArrayList](https://ziglang.org/documentation/master/std/#std.ArrayList)ï¼Œæˆ‘ä»¬è·Ÿéšæ ‡å‡†åº“ç§°ä¹‹ä¸ºåˆ—è¡¨ï¼ˆListï¼‰ã€‚
:::

æ­£å¦‚å…¶åï¼ŒSimpleArrayListä½¿ç”¨æ™®é€šçš„æ•°ç»„å­˜å‚¨æ•°æ®ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å­˜å‚¨äº†å¤šå°‘ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”éœ€è¦èƒ½åœ¨éœ€è¦æ—¶æ‰©å¤§å†…éƒ¨å­˜å‚¨ç”¨çš„æ•°ç»„ã€‚ç”±æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸‹é¢çš„åŸºæœ¬çš„å®šä¹‰ï¼š

```zig
const SimpleArrayList = struct {
    allocator: std.mem.Allocator,   // å†…å­˜åˆ†é…å™¨ï¼Œç”¨äºŽåŠ¨æ€åˆ†é…å†…å­˜
    items: []???,                  // åˆ—è¡¨å†…å…ƒç´ 
    len: usize,                     // åˆ—è¡¨å†…å…ƒç´ çš„æ•°é‡
};
```

### å®žçŽ°**æ³›åž‹**

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œ`items`åº”è¯¥æ˜¯ä»€ä¹ˆç±»åž‹çš„å‘¢ï¼Ÿä¸ºäº†èƒ½ä½¿åˆ—è¡¨é€‚ç”¨äºŽä¸åŒç±»åž‹çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦**æ³›åž‹**ã€‚ç®€å•æ¥è¯´ï¼Œæ³›åž‹å°±æ˜¯é€šè¿‡æŸç§æ–¹å¼ï¼Œä½¿å¾—å‡½æ•°æˆ–æ˜¯ç»“æž„ä½“å¯ä»¥æŽ¥æ”¶ä¸åŒçš„ç±»åž‹ä½œä¸ºå‚æ•°æˆ–æˆå‘˜ã€‚

æˆ‘ä»¬å‰é¢è¯´è¿‡ï¼Œåœ¨Zigä¸­ç±»åž‹æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥å°†ç±»åž‹ä½œä¸ºå‚æ•°ä¼ ç»™å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºè¿”å›žå€¼è¿”å›žã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼å®žçŽ°æ³›åž‹ã€‚æˆ‘ä»¬å¯ä»¥å£°æ˜Žä¸€ä¸ªå‡½æ•°ï¼ŒæŽ¥æ”¶ä¸€ä¸ªç±»åž‹Tï¼Œç„¶åŽè¿”å›žå­˜å‚¨ç±»åž‹Tçš„å…ƒç´ çš„åˆ—è¡¨ã€‚

```zig
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,
    };
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬é‡åˆ°äº†å‡ ä¸ªæ²¡è§è¿‡çš„ä¸œè¥¿ï¼š

1. å…³é”®è¯`comptime`ï¼šè¿™æ˜¯Zigçš„ä¸€ä¸ªé‡è¦å±žæ€§ï¼Œå®ƒæœ‰å¾ˆå¤šç”¨å¤„ï¼Œåœ¨è¿™é‡Œï¼Œå®ƒæ„å‘³ç€Tæ˜¯ä¸€ä¸ªåœ¨ç¼–è¯‘çš„æ—¶å€™å°±å·²çŸ¥çš„å€¼ï¼›
2. ç±»åž‹`type`ï¼šè¿™ä¸ªç±»åž‹æ˜¯â€œç±»åž‹çš„ç±»åž‹â€ï¼›

é€šè¿‡è¿™ç§æ–¹å¼è¿”å›žçš„ç»“æž„ä½“çš„åå­—æ¯”è¾ƒå¤æ‚ï¼Œä¸æ–¹ä¾¿ä½¿ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨Zigçš„å†…å»ºå‡½æ•°æ¥æž„å»ºä¸€ä¸ªåˆ«åæ¥ã€‚

```zig {3}
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,
    };
}
```

åœ¨ç¬¬3è¡Œä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨`@This()`å‡½æ•°èŽ·å¾—äº†å½“å‰ç»“æž„çš„ç±»åž‹ã€‚

::: tip
åœ¨æ‰€æœ‰å†…å»ºå‡½æ•°ä¸­ï¼Œä»¥å¤§å†™å­—æ¯å¼€å¤´çš„å‡½æ•°éƒ½è¿”å›ž`type`ç±»åž‹çš„å€¼ï¼Œä¾‹å¦‚è¿™é‡Œçš„`@This()`ã€‚

è¿™é‡Œçš„æˆå‘˜è¢«å‘½åä¸º`This`ï¼Œä½†è¿™ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œç”¨ä½ å–œæ¬¢çš„å°±è¡Œã€‚
:::

### åˆå§‹åŒ–å’Œååˆå§‹åŒ–

è®©æˆ‘ä»¬æ‰¾ä¸€ä¸ªåœ°æ–¹æ¥åˆå§‹åŒ–æ•°æ®ç»“æž„ã€‚

æŒ‰ç…§çº¦å®šä¿—æˆï¼Œä¸€èˆ¬å£°æ˜Žä¸€ä¸ªåä¸º`init`çš„å‡½æ•°ä½œä¸ºåˆå§‹åŒ–å‡½æ•°ï¼Œä¸€ä¸ªåä¸º`deinit`çš„å‡½æ•°ä½œä¸ºååˆå§‹åŒ–å‡½æ•°ã€‚

å‡½æ•°åº”è¯¥æ”¾åœ¨å“ªé‡Œå‘¢ï¼Ÿåœ¨Cä¸­ï¼Œæˆ‘ä»¬æŠŠæˆå‘˜å®šä¹‰åœ¨ç»“æž„ä½“å†…ï¼Œç„¶åŽåœ¨ç»“æž„ä½“å¤–ç”¨ä¸€ä¸ªå¾ˆé•¿çš„å‰ç¼€æ¥åŒºåˆ†ï¼Œæ¯”å¦‚ï¼š

```c
typedef struct {
    int *items;
    int len;
} SimpleArrayListInt;

void simple_array_list_int_init(SimpleArrayListInt*);
```

åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬ä¼šç›´æŽ¥åœ¨ç±»çš„å®šä¹‰å†…å®šä¹‰ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ï¼Œæ¯”å¦‚ï¼š

```python
class SimpleArrayInit():
    def __init__(self):
        pass
```

åœ¨Zigä¸­ï¼Œæˆ‘ä»¬ç»“åˆè¿™ä¸¤ç§å½¢å¼ï¼šåœ¨ç»“æž„ä½“å†…å£°æ˜Žå‡½æ•°ï¼Œæ¯”å¦‚ï¼š

```zig {9}
pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const DefaultCapacity: usize = 10;
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .items = try allocator.alloc(T, This.DefaultCapacity),
                .len = 0,
            };
        }
    };
}
```

é™¤äº†`init`ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå¯¹åº”çš„`deinit`ï¼Œä»¥ä¾¿åœ¨éœ€è¦çš„æ—¶å€™é‡Šæ”¾ç”³è¯·çš„å†…å­˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦é‡Šæ”¾`items`è¿™ä¸ªæˆå‘˜ã€‚

```zig
        pub fn deinit(self: This) void {
            self.allocator.free(self.items);
        }
```

ç»„è£…èµ·æ¥ï¼Œæˆ‘ä»¬å°±æœ‰äº†ä¸€ä¸ªSimpleArrayListçš„åŸºæœ¬æ¡†æž¶ï¼š

```zig
const std = @import("std");

pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const DefaultCapacity: usize = 10;
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .items = try allocator.alloc(T, This.DefaultCapacity),
                .len = 0,
            };
        }

        pub fn deinit(self: This) void {
            self.allocator.free(self.items);
        }
    };
}

pub fn main() !void {
    const a = try SimpleArrayList(i8).init(std.heap.page_allocator);
    defer a.deinit();
    std.debug.print("{} of {}\n", .{ a.len, a.items.len });
}
```

```ansi
$stdout returns nothing.
$stderr:
0 of 10
```

ä»Žè¿è¡Œç»“æžœæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬æˆåŠŸåœ°åˆ†é…äº†10ä¸ªå…ƒç´ çš„ç©ºé—´ï¼Œä¸è¿‡æš‚æ—¶è¿˜æ²¡æœ‰å­˜å‚¨ä»»ä½•å…ƒç´ è¿›åŽ»ã€‚

::: tip
å¦å¤–ï¼Œè¿™é‡Œæˆ‘ä»¬åˆé‡è§äº†ä¸€ä¸ªä¸è®¤è¯†çš„å…³é”®è¯â€”â€”`defer`ã€‚å¦‚æžœä½ æœ‰Goè¯­è¨€çš„ä½¿ç”¨ç»éªŒï¼Œè¿™å¯èƒ½ä¼šå¾ˆçœ¼ç†Ÿã€‚åœ¨deferå…³é”®è¯åŽçš„è¯­å¥ä¼šåœ¨å½“å‰ä½œç”¨åŸŸç»“æŸæ—¶è¢«æ‰§è¡Œã€‚ä¸ä¸¥è°¨åœ°è¯´ï¼Œä¼šåœ¨ä¸‹ä¸€ä¸ªèŠ±æ‹¬å·åŽæ‰§è¡Œã€‚ä¸‹é¢çš„ä¾‹å­å¯ä»¥è¯´æ˜Žä¸åŒçš„æ‰§è¡Œé¡ºåºã€‚
```zig
const std = @import("std");
const print = std.debug.print;

pub fn main() void {
    print("1\n", .{});  // æ‰“å°1
    defer print("2\n", .{});

    {
        defer print("3\n", .{});
        print("4\n", .{});  // æ‰“å°4
        {
            defer print("5\n", .{});
            print("6\n", .{});  // æ‰“å°6
        }   // æ‰“å°5
    }   // æ‰“å°3

}   // æ‰“å°2
```

```ansi
$stdout returns nothing.
$stderr:
1
4
6
5
3
2
```

:::

::: warning
æˆ‘ä»¬åº”è¯¥åœ¨ä¸éœ€è¦ä¸€å—å†…å­˜åŽå°½å¯èƒ½åœ°é‡Šæ”¾æŽ‰å®ƒï¼Œä»¥ä¾¿å‡è½»ç®¡ç†å†…å­˜çš„å¤æ‚åº¦ã€‚

å¤§é‡åˆ†é…å†…å­˜è€Œä¸é‡Šæ”¾ä¼šå¯¼è‡´**å†…å­˜æ³„æ¼**ï¼Œé€ æˆèµ„æºæµªè´¹ã€‚
:::

æˆ‘ä»¬è¿˜éœ€è¦ä»€ä¹ˆå‡½æ•°å‘¢ï¼Ÿæˆ‘ä»¬æƒ³è¦èŽ·å–æŸä¸ªä¸‹æ ‡å¤„çš„å…ƒç´ ï¼Œæƒ³è¦ä¿®æ”¹æŸä¸ªä¸‹æ ‡å¤„çš„å…ƒç´ ï¼Œæƒ³è¦æ’å…¥æ–°çš„å…ƒç´ ï¼Œæƒ³è¦åœ¨åˆ—è¡¨æœ«å°¾æ·»åŠ æ–°çš„å…ƒç´ ã€‚æ€»ç»“ä¸€ä¸‹ï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦ä¸‹é¢çš„å››ä¸ªå‡½æ•°ï¼š

1. nth(n)ï¼šè®¿é—®ä¸‹æ ‡ä¸ºnçš„å…ƒç´ ï¼›
2. setNth(n, v)ï¼šå°†ä¸‹æ ‡ä¸ºnçš„å…ƒç´ è®¾ç½®ä¸ºvï¼›
3. insertNth(n, v)ï¼šåœ¨ä¸‹æ ‡nå¤„æ’å…¥å…ƒç´ vï¼›
4. append(v)ï¼šåœ¨åˆ—è¡¨æœ«å°¾è¿½åŠ å…ƒç´ vï¼›
5. removeNth(n)ï¼šåˆ é™¤ä¸‹æ ‡ä¸ºnçš„å…ƒç´ ï¼›

æˆ‘ä»¬ä»Ž`nth`å¼€å§‹å§ã€‚

### nth

æœ€ç¬¦åˆç›´è§‰çš„ï¼Œæˆ‘ä»¬ä»Ž`items`æˆå‘˜ä¸­å–å‡ºä¸€ä¸ªå…ƒç´ ï¼š

```zig
pub fn nth(self: This, n: usize) T {
    return self.items[n];
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ³¨æ„åˆ°ä¸€ä¸ªæ–°çš„æ¦‚å¿µâ€”â€”selfã€‚å¦‚æžœä½ æœ‰ä½¿ç”¨Pythonçš„ç»éªŒï¼Œä½ åº”è¯¥ä¼šè§‰å¾—çœ¼ç†Ÿã€‚è¿™é‡Œçš„selfæŒ‡çš„æ˜¯è¢«æˆå‘˜è®¿é—®è¿ç®—ç¬¦`.`è®¿é—®çš„å¯¹è±¡ï¼Œæ¯”å¦‚è¯´å¦‚æžœæˆ‘ä»¬è°ƒç”¨`list.nth(1)`ï¼Œé‚£ä¹ˆè¿™é‡Œçš„selfå°±æ˜¯listã€‚

selfä¹Ÿå¯ä»¥å«å…¶ä»–åå­—ï¼Œåªè¦ä»–æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°å°±è¡Œã€‚å½“ç»“æž„ä½“å†…çš„æŸä¸ªå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºselfï¼ˆä¹Ÿå¯ä»¥å«å…¶ä»–åå­—ï¼‰æ—¶ï¼Œæˆ‘ä»¬ç§°å®ƒä¸ºä¸€ä¸ª**æ–¹æ³•**ã€‚

å¦‚æžœæˆ‘ä»¬éœ€è¦ä¿®æ”¹selfçš„å†…å®¹çš„è¯ï¼Œä¹Ÿå¯ä»¥ä¼ å…¥æŒ‡é’ˆä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ã€‚

ä¸Šé¢çš„å®žçŽ°æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜ï¼š`n`è¿™ä¸ªä½ç½®ä¸Šä¸ä¸€å®šæœ‰å…ƒç´ ï¼Œ`items`ä¹Ÿä¸ä¸€å®šæœ‰è¿™ä¹ˆå¤§ï¼Œè¿™ä¼šé€ æˆè¢«ç§°ä¸º**ä¸‹æ ‡è¶Šç•Œ**çš„é—®é¢˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯¹ä¸‹æ ‡nè¿›è¡Œæ£€æŸ¥ï¼Œå¦‚æžœè¶…å‡ºè¾¹ç•Œå°±è¿”å›žé”™è¯¯ï¼Œå¦‚æžœæ­£å¸¸è®¿é—®åˆ™è¿”å›žå…ƒç´ ã€‚æ²¡é”™ï¼Œæˆ‘ä»¬å°†ä¼šç”¨åˆ°é”™è¯¯è”åˆç±»åž‹ã€‚

```zig
pub fn nth(self: This, n: usize) !T {
    if (n >= self.len) {
        return error.IndexOutOfBound;
    }
    return self.items[n];
}
```

å› ä¸ºnæ˜¯usizeç±»åž‹ï¼Œæ‰€ä»¥å®ƒä¸ä¼šå°äºŽ0ï¼›`self.len`ä¸€å®šå°äºŽç­‰äºŽ`self.items.len`ï¼Œæ‰€ä»¥åªè¦nå¤§äºŽself.lenï¼Œå°±æ²¡æœ‰å¿…è¦åˆ¤æ–­æ˜¯å¦å¤§äºŽself.items.lenï¼Œä¸€å®šæ˜¯ä¸‹æ ‡è¶Šç•Œã€‚

### setNth

ç±»ä¼¼äºŽ`nth`ï¼Œ`setNth`ä¹Ÿè¦æ£€æŸ¥è¾¹ç•Œã€‚å½“å‘ç”Ÿä¸‹æ ‡è¶Šç•Œæ—¶ï¼Œæˆ‘ä»¬è¿”å›žä¸€æ ·çš„é”™è¯¯ï¼›å½“æ²¡æœ‰å‘ç”Ÿé”™è¯¯æ—¶ï¼Œæˆ‘ä»¬è¿”å›žvoidã€‚

```zig
pub fn setNth(self: *This, n: usize, v: T) !void {
    if (n >= self.len) {
        return error.IndexOutOfBound;
    }
    self.items[n] = v;
}
```

æ­£å¦‚å‰æ–‡æ‰€è¨€ï¼Œæ­¤å¤„æˆ‘ä»¬éœ€è¦ä¿®æ”¹åˆ—è¡¨ï¼Œå› æ­¤æˆ‘ä»¬ä¼ å…¥çš„å‚æ•°ç±»åž‹ä¸ºæŒ‡é’ˆã€‚

::: warning
å‡è®¾ä½ æœ‰ä¸€ä¸ªåˆ—è¡¨çš„å®žä¾‹`a`ï¼Œä½ å¸Œæœ›é€šè¿‡`setNth`æ¥è®¾ç½®å…ƒç´ ï¼Œé‚£ä¹ˆä½ å¿…é¡»å£°æ˜Žaä¸ºä¸€ä¸ªå¯å˜é‡ï¼Œä¹Ÿå°±æ˜¯å¿…é¡»é€šè¿‡`var`å…³é”®è¯å£°æ˜Žè¿™ä¸ªå˜é‡ï¼š

```zig
var a = try SimpleArrayList(i8).init(std.heap.page_allocator);
defer a.deinit();
std.debug.print("{!}\n", .{a.setNth(10, 8)});
```

å¦‚æžœä½ ä½¿ç”¨`const`å£°æ˜Žäº†ä¸€ä¸ªä¸å¯å˜é‡ï¼Œç¼–è¯‘å™¨å°†ä¼šæŠ¥é”™ã€‚

```zig
// error: expected type '*02_array.SimpleArrayList(i8)', found '*const 02_array.SimpleArrayList(i8)'
const a = try SimpleArrayList(i8).init(std.heap.page_allocator);
defer a.deinit();
std.debug.print("{!}\n", .{a.setNth(10, 8)});
```
:::

### append

åœ¨å®žçŽ°`insertNth`ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå®žçŽ°ç›¸å¯¹ç®€å•çš„`append`ã€‚

æˆ‘ä»¬çš„åŸºæœ¬è¯‰æ±‚æ˜¯åœ¨åˆ—è¡¨çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œæœ€ç®€åŒ–çš„å®žçŽ°å¦‚ä¸‹ï¼š

```zig
pub fn append(self: *This, v: T) void {
    self.items[self.len] = v;
    self.len += 1;
}
```

æˆ‘ä»¬ä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼šåœ¨`init`å‡½æ•°é‡Œï¼Œæˆ‘ä»¬åªç»™`items`åˆ†é…äº†10ä¸ªå…ƒç´ çš„ç©ºé—´ï¼Œå¦‚æžœæˆ‘ä»¬é€šè¿‡ä¸Šé¢çš„è¿™ä¸ª`append`æ·»åŠ äº†11ä¸ªå…ƒç´ ï¼Œå°±ä¼šè¶…å‡ºitemsçš„èŒƒå›´ï¼Œé‡åˆ°ä¸‹æ ‡è¶Šç•Œã€‚è¿™è¯¥æ€Žä¹ˆåŠžï¼Ÿæˆ‘ä»¬åªéœ€è¦åœ¨æ·»åŠ å…ƒç´ å‰ï¼Œåˆ¤æ–­ç©ºé—´æ˜¯å¦è¶³å¤Ÿï¼Œå¦‚æžœä¸å¤Ÿå°±æ‰©å®¹ã€‚è¿™æ ·ï¼Œå°±ä¸ä¼šå‡ºçŽ°ç©ºé—´ä¸è¶³çš„é—®é¢˜ã€‚æˆ‘ä»¬å¢žåŠ ä¸€ä¸ªæ–°çš„æ–¹æ³•`enlarge`æ¥å¢žå¤§ç©ºé—´ã€‚

#### enlarge

è¿™ä¸ªæ–¹æ³•çš„åŸºæœ¬æµç¨‹ä¸ºï¼š

1. åˆ†é…æ›´å¤§çš„ç©ºé—´ï¼›
2. å¤åˆ¶å…ƒç´ åˆ°æ–°çš„ç©ºé—´ä¸­ï¼›
3. é‡Šæ”¾åŽŸæ¥çš„ç©ºé—´ï¼›

ä¸€ä¸ªç®€å•çš„å®žçŽ°å¦‚ä¸‹ï¼š

```zig
pub fn enlarge(self: *This) !void {
    // è®¡ç®—â€œæ›´å¤§çš„ç©ºé—´â€æœ‰å¤šå¤§
    // å› ä¸ºZigä¸ä¼šè¿›è¡Œä¸å®‰å…¨çš„éšå¼ç±»åž‹è½¬æ¢ï¼Œä¸ºäº†è®©usizeç±»åž‹çš„self.items.lenå’Œ1.5ç›¸ä¹˜ï¼Œæˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨è¿›è¡Œè½¬æ¢
    const new_capacity: usize = @intFromFloat(@as(f32, @floatFromInt(self.items.len)) * @as(f32, 1.5));
    // 1. åˆ†é…æ›´å¤§çš„ç©ºé—´
    const new_items = try self.allocator.alloc(T, new_capacity);
    // 2. å¤åˆ¶å…ƒç´ åˆ°æ–°ç©ºé—´ä¸­
    std.mem.copyForwards(T, new_items, self.items);
    // 3. é‡Šæ”¾åŽŸæ¥çš„ç©ºé—´
    self.allocator.free(self.items);
    self.items = new_items;
}
```

æˆ‘ä»¬å°†ä»£ç æ®µå¯¹åº”çš„æ­¥éª¤å†™åœ¨äº†æ³¨é‡Šä¸­ã€‚

æœ‰äº†enlargeï¼Œæˆ‘ä»¬ç»ˆäºŽå¯ä»¥å®žçŽ°appendäº†ã€‚

#### append

appendçš„åŸºæœ¬æ­¥éª¤ä¸ºï¼š

1. åˆ¤æ–­ç©ºé—´æ˜¯å¦å……è¶³ï¼Œæ˜¯åˆ™åˆ°æ­¥éª¤3ï¼Œå¦åˆ™åˆ°æ­¥éª¤2ï¼›
2. ä½¿ç”¨enlargeæ–¹æ³•æ‰©å¤§ç©ºé—´ï¼›
3. åœ¨æœ«å°¾å¢žåŠ å…ƒç´ ï¼›

```zig
pub fn append(self: *This, v: T) !void {
    // 1. åˆ¤æ–­å¤§å°
    if (self.len >= self.items.len) {
        // 2. æ‰©å¤§ç©ºé—´
        try self.enlarge();
    }
    // å¢žåŠ å…ƒç´ 
    self.items[self.len] = v;
    self.len += 1;
}
```
### insertNth

`insertNth`çš„æ“ä½œå’Œ`append`æœ‰å¾ˆå¤šç›¸ä¼¼ä¹‹å¤„ï¼Œå¹¶ä¸”éœ€è¦è¿›è¡Œä¸‹æ ‡æ£€æŸ¥ï¼ŒåŸºæœ¬æ­¥éª¤åŒ…æ‹¬ï¼š

1. åˆ¤æ–­ä¸‹æ ‡æ˜¯å¦è¶Šç•Œï¼Œæ˜¯åˆ™è¿”å›žä¸‹æ ‡è¶Šç•Œé”™è¯¯ï¼Œå¦åˆ™ç»§ç»­ï¼›
2. åˆ¤æ–­ç©ºé—´æ˜¯å¦å……è¶³ï¼Œæ˜¯åˆ™åˆ°æ­¥éª¤4ï¼Œå¦åˆ™åˆ°æ­¥éª¤3ï¼›
3. ä½¿ç”¨enlargeæ–¹æ³•æ‰©å¤§ç©ºé—´ï¼›
4. åˆ¤æ–­nä½ç½®æ˜¯å¦æœ‰å…ƒç´ ï¼Œæœ‰åˆ™åˆ°æ­¥éª¤5ï¼Œå¦åˆ™åˆ°æ­¥éª¤6ï¼›
5. å°†nä½ç½®çš„å…ƒç´ åŠå…¶åŽé¢çš„å…ƒç´ å…¨éƒ¨åŽç§»ä¸€ä½ï¼›
6. åœ¨nä½ç½®æ’å…¥å…ƒç´ ï¼›

```zig
pub fn insertNth(self: *This, n: usize, v: T) !void {
    // 1. åˆ¤æ–­ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ
    // ä¸Žnthå’ŒsetNthä¸åŒï¼Œæˆ‘ä»¬å…è®¸nç­‰äºŽself.lenï¼Œæ­¤æ—¶insertNthç›¸å½“äºŽappend
    if (n > self.len) {
        return error.IndexOutOfBound;
    }
    // 2. åˆ¤æ–­ç©ºé—´æ˜¯å¦å……è¶³
    if (self.len >= self.items.len) {
        // 3. ä½¿ç”¨enlargeæ–¹æ³•æ‰©å¤§ç©ºé—´
        try self.enlarge();
    }
    // 4,5. å°†nä½ç½®åŽé¢çš„å…ƒç´ å¾€åŽç§»ä¸€ä½
    // åœ¨å®žé™…å®žè·µä¸­ï¼Œåªæœ‰åœ¨nç­‰äºŽself.lenæ—¶ï¼Œnä½ç½®ä¸Šæ‰æ²¡æœ‰å…ƒç´ ï¼Œæ‰€ä»¥å¯ä»¥è·³è¿‡åˆ¤æ–­è¿™ä¸€æ­¥
    var i = self.len;
    while (i >= n + 1) : (i -= 1) {
        self.items[i] = self.items[i - 1];
    }
    // 6. åœ¨nä½ç½®æ’å…¥å…ƒç´ 
    self.items[n] = v;
    self.len += 1;
}
```

### removeNth

`removeNth`åˆ é™¤ä¸‹æ ‡nå¤„çš„å…ƒç´ ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è¿›è¡Œä¸‹æ ‡æ£€æŸ¥ã€‚å› ä¸ºåˆ—è¡¨ä¸­å­˜å‚¨çš„å…ƒç´ å¯èƒ½éœ€è¦è¿›è¡Œååˆå§‹åŒ–ç­‰æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸åº”è¯¥ç›´æŽ¥è¦†ç›–è¿™ä¸ªå…ƒç´ ï¼Œè€Œåº”è¯¥è¿”å›žè¿™ä¸ªå…ƒç´ ã€‚ç»¼ä¸Šï¼ŒåŸºæœ¬æ­¥éª¤ä¸ºï¼š

1. åˆ¤æ–­ä¸‹æ ‡æ˜¯å¦è¶Šç•Œï¼Œæ˜¯åˆ™è¿”å›žä¸‹æ ‡è¶Šç•Œé”™è¯¯ï¼Œå¦åˆ™ç»§ç»­ï¼›
2. å°†nä½ç½®å¤„å…ƒç´ ä¿å­˜ä¸ºtempï¼›
3. å°†nä½ç½®ä¹‹åŽçš„å…ƒç´ å…¨éƒ¨å‰ç§»ä¸€ä½ï¼›
4. è¿”å›žtempï¼›

```zig
pub fn removeNth(self: *This, n: usize) !T {
    // 1. åˆ¤æ–­ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ
    if (n >= self.len) {
        return error.IndexOutOfBound;
    }
    // 2. å°†nä½ç½®å¤„å…ƒç´ ä¿å­˜ä¸ºtemp
    const temp = self.items[n];
    // 3. å°†nä½ç½®ä¹‹åŽçš„å…ƒç´ å…¨éƒ¨å‰ç§»ä¸€ä½
    for (n..self.len - 1) |i| {
        self.items[i] = self.items[i + 1];
    }
    self.len -= 1;
    // 4. è¿”å›žtemp
    return temp;
}
```

::: tip
æ‰€æœ‰æ¶‰åŠåˆ°`nth`ï¼Œä¹Ÿå°±æ˜¯é€šè¿‡ä¸‹æ ‡è®¿é—®çš„æ–¹æ³•ï¼Œéƒ½åº”è¯¥è¿›è¡Œä¸‹æ ‡æ£€æŸ¥ã€‚
:::

## æµ‹è¯•

Zigè‡ªå¸¦ä¸€ä¸ªä¾¿åˆ©çš„æµ‹è¯•åŠŸèƒ½ï¼Œ[Zig Test](https://ziglang.org/documentation/master/#Zig-Test)ã€‚

åˆ›å»ºä¸€ä¸ªåä¸º`add_two.zig`çš„æ–‡ä»¶ï¼Œç„¶åŽè¾“å…¥ä¸‹é¢çš„å†…å®¹ï¼š

```zig
const std = @import("std");

pub fn add(a: i32, b: i32) i32 {
    return a + b;
}

test "test adding" {
    try std.testing.expect(add(1, 1) == 2);
}
```

åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåä¸º`add`çš„å‡½æ•°ï¼Œå®ƒå°†è¾“å…¥çš„ä¸¤ä¸ªæ•°å­—ç›¸åŠ å¹¶è¿”å›žã€‚

éšåŽï¼Œæˆ‘ä»¬é€šè¿‡å…³é”®å­—`test`å£°æ˜Žäº†ä¸€ä¸ªåä¸º`test adding`çš„æµ‹è¯•ã€‚æµ‹è¯•æœ‰ä¸€ç‚¹åƒå‡½æ•°ï¼Œä½†å®ƒä¸æŽ¥å—ä»»ä½•å‚æ•°ã€‚ç±»ä¼¼äºŽå‡½æ•°çš„å‡½æ•°ä½“ï¼Œæµ‹è¯•ä¹Ÿæœ‰ä¸€ä¸ªâ€œæµ‹è¯•ä½“â€ã€‚åœ¨â€œæµ‹è¯•ä½“ä¸­â€ï¼Œæˆ‘ä»¬ä½¿ç”¨`std.testing.expect`å‡½æ•°ï¼Œæ¥åˆ¤æ–­add(1, 2)çš„ç»“æžœæ˜¯ä¸æ˜¯2ã€‚`std.testing.expect(ok)`å‡½æ•°æŽ¥æ”¶ä¸€ä¸ªå¸ƒå°”åž‹å˜é‡okï¼Œå½“okçš„å€¼ä¸ºfalseæ—¶ï¼Œè¿”å›žä¸€ä¸ªé”™è¯¯ï¼Œå½“okçš„å€¼ä¸ºtrueæ—¶ï¼Œä¸è¿”å›žå€¼ï¼ˆvoidï¼‰ã€‚

è¿è¡Œ`zig test add_two.zig`ï¼ŒZigå°†ä¼šè‡ªåŠ¨å¯»æ‰¾è¯¥æ–‡ä»¶é‡Œçš„æ‰€æœ‰æµ‹è¯•ï¼Œç„¶åŽè¿”å›žç»“æžœï¼š

```ansi
All 1 tests passed.
```

æˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸€åŠŸèƒ½å¯¹æˆ‘ä»¬çš„SimpleArrayListè¿›è¡Œæµ‹è¯•ã€‚

æˆ‘ä»¬ä¸ä¼šåœ¨è¿™é‡Œä»‹ç»è½¯ä»¶æµ‹è¯•ç›¸å…³çš„çŸ¥è¯†ï¼Œé‚£æ ·å’Œæˆ‘ä»¬çš„åˆè¡·ä¸ç¬¦ã€‚æˆ‘ä»¬åˆ¶ä½œæœ€ç®€å•çš„â€”â€”åŠŸèƒ½æµ‹è¯•ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åªæ˜¯ç®€å•çš„æµ‹è¯•æˆ‘ä»¬å®žçŽ°çš„åŠŸèƒ½ã€‚

æˆ‘ä»¬å°†ä»Žå®žçŽ°çš„å‡ ä¸ªå‡½æ•°å‡ºå‘è¿›è¡Œæµ‹è¯•ã€‚

::: tip
åœ¨å®žé™…å®žè·µä¸­ï¼Œæµ‹è¯•è¦è€ƒè™‘çš„æœ‰å¾ˆå¤šã€‚

åœ¨è¿™é‡Œç•™ä¸€ä¸ªç»å…¸çš„è½¯ä»¶æµ‹è¯•ç¬‘è¯ï¼š

::: details ç‚¹æˆ‘æŸ¥çœ‹ç¬‘è¯
ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†ä¸€æ¯å•¤é…’

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†ä¸€æ¯å’–å•¡

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†0.7æ¯å•¤é…’

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†-1æ¯å•¤é…’

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†2^32æ¯å•¤é…’

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†ä¸€æ¯æ´—è„šæ°´

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†ä¸€æ¯èœ¥èœ´

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†ä¸€ä»½asdfQwer@24dg!&*(@

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œä»€ä¹ˆä¹Ÿæ²¡è¦

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œåˆèµ°å‡ºåŽ»åˆä»Žçª—æˆ·è¿›æ¥åˆä»ŽåŽé—¨å‡ºåŽ»ä»Žä¸‹æ°´é“é’»è¿›æ¥

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œåˆèµ°å‡ºåŽ»åˆè¿›æ¥åˆå‡ºåŽ»åˆè¿›æ¥åˆå‡ºåŽ»ï¼Œæœ€åŽåœ¨å¤–é¢æŠŠè€æ¿æ‰“äº†ä¸€é¡¿

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†ä¸€æ¯çƒ«çƒ«çƒ«çš„é”Ÿæ–¤æ‹·

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†NaNæ¯Null

1Tæµ‹è¯•å·¥ç¨‹å¸ˆå†²è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†500Tå•¤é…’å’–å•¡æ´—è„šæ°´é‡ŽçŒ«ç‹¼ç‰™æ£’å¥¶èŒ¶

1Tæµ‹è¯•å·¥ç¨‹å¸ˆæŠŠé…’å§æ‹†äº†

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆåŒ–è£…æˆè€æ¿èµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†500æ¯å•¤é…’å¹¶ä¸”ä¸ä»˜é’±

ä¸€ä¸‡ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆåœ¨é…’å§é—¨å¤–å‘¼å•¸è€Œè¿‡

ä¸€ä¸ªæµ‹è¯•å·¥ç¨‹å¸ˆèµ°è¿›ä¸€å®¶é…’å§ï¼Œè¦äº†ä¸€æ¯å•¤é…’';DROP TABLE é…’å§

æµ‹è¯•å·¥ç¨‹å¸ˆä»¬æ»¡æ„åœ°ç¦»å¼€äº†é…’å§ã€‚ç„¶åŽä¸€åé¡¾å®¢ç‚¹äº†ä¸€ä»½ç‚’é¥­ï¼Œé…’å§ç‚¸äº†

---

è½¬è½½è‡ª[**ä»Šæ—¥é£žé›ª**çš„çŸ¥ä¹Žå›žç­”](https://www.zhihu.com/question/20034686/answer/52063718)
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚
:::

æˆ‘ä»¬é€ä¸ªå‡½æ•°åœ°ç¼–å†™å‡½æ•°ï¼Œç„¶åŽæ”¾åˆ°åŒä¸€ä¸ªæ–‡ä»¶é‡Œåšæµ‹è¯•ã€‚

åˆ›å»ºä¸€ä¸ªåä¸º`0202_array_test.zig`çš„æ–‡ä»¶ï¼Œå‘å…¶ä¸­æ’å…¥ä¸‹é¢çš„ä»£ç ï¼š

```zig
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;
const array = @import("02_array.zig"); // æˆ‘ä»¬å®žçŽ°çš„SimpleArrayListä¿å­˜åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­
```

ä¸Šé¢æåˆ°çš„æ–‡ä»¶`02_array.zig`çš„å†…å®¹å¯ä»¥åœ¨[æ–‡æœ«](#full-code)æ‰¾åˆ°ã€‚

### append

æˆ‘ä»¬å…ˆæ¥æµ‹è¯•appendï¼Œä¹Ÿå°±æ˜¯å‘åˆ—è¡¨æœ«å°¾æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚

```zig
test "test nth" {
    // æˆ‘ä»¬ä½¿ç”¨std.testing.allocator
    // è¿™ä¸ªåˆ†é…å™¨é€‚åˆä¸éœ€è¦åˆ†é…å¤§å—å†…å­˜çš„æµ‹è¯•åœºæ™¯
    // å®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬æ£€æµ‹æ½œè—çš„å†…å­˜æ³„æ¼
    const allocator = std.testing.allocator;
    var list = try array.SimpleArrayList(u32).init(allocator);
    // æ³¨é‡Šä¸‹é¢è¿™ä¸€è¡Œï¼Œzig testä¼šè‡ªåŠ¨æ£€æŸ¥åˆ°å†…å­˜æ³„æ¼
    defer list.deinit();
    // æ’å…¥17ä¸ªæ•°å­—
    for (0..17) |value| {
        // valueæ˜¯usizeç±»åž‹çš„ï¼Œè¿™ä¸ªç±»åž‹åœ¨æˆ‘çš„ç”µè„‘ä¸Šæ˜¯u64ï¼Œå¤§äºŽu32ï¼Œæ‰€ä»¥u64è½¬æ¢ä¸ºu32æ˜¯ä¸å®‰å…¨çš„
        // zigä¸ä¼šè‡ªåŠ¨è¿›è¡Œä¸å®‰å…¨çš„ç±»åž‹è½¬æ¢
        // æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è½¬æ¢æ•°æ®ç±»åž‹
        try list.append(@as(u32, @intCast(value)));
    }
    // çœŸå®žå€¼
    const actual = [17]u32{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
    // æ’å…¥17ä¸ªæ•°å­—åŽï¼Œé•¿åº¦åº”è¯¥ä¸º17
    try expect(list.len == 17);
    // æ’å…¥17ä¸ªæ•°å­—ï¼Œä¼šè§¦å‘ä¸¤æ¬¡æ‰©å®¹ï¼Œlist.items.lenåº”è¯¥ä¸º22
    try expect(list.items.len == 22);
    // std.mem.eqlå¯ä»¥å¯¹æ¯”ä¸¤ä¸ªæ•°ç»„/åˆ‡ç‰‡ï¼ˆsliceï¼‰æ˜¯å¦ç›¸åŒ
    try expect(std.mem.eql(u32, list.items[0..17], &actual));
}
```

æˆ‘ä»¬ä»Žå°è¯•å‘åˆ—è¡¨æœ«å°¾æŒ‰é¡ºåºæ·»åŠ 0åˆ°16å…±17ä¸ªæ•°å­—ï¼Œç„¶åŽåˆ¤æ–­åˆ—è¡¨é•¿åº¦ã€åˆ—è¡¨å®¹é‡ï¼ˆä¹Ÿå°±æ˜¯list.items.lenï¼‰ä»¥åŠåˆ—è¡¨å†…çš„å…ƒç´ æ˜¯å¦æ˜¯æˆ‘ä»¬æœŸæœ›çš„é‚£æ ·ã€‚

åœ¨åˆ¤æ–­åˆ—è¡¨å†…å…ƒç´ æ˜¯å¦ç›¸ç­‰æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†åˆ‡ç‰‡è¯­æ³•`list.items[0..17]`ï¼Œè¿™é‡Œå–äº†list.itemsçš„ä¸‹æ ‡ä¸º0åˆ°17ï¼ˆä¸åŒ…æ‹¬17ï¼‰çš„å…±17ä¸ªå…ƒç´ çš„åˆ‡ç‰‡ã€‚

æˆ‘ä»¬è¿™é‡Œå†™äº†ï¼Œåˆ—è¡¨å®¹é‡ä¸º22ï¼Œä½†åˆ—è¡¨é•¿åº¦ä¸º22ï¼Œä½†æ˜¯æˆ‘ä»¬åªåˆ¤æ–­äº†å‰17ä¸ªå…ƒç´ ï¼Œé‚£å‰©ä¸‹çš„5ä¸ªæ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Ÿä½ å¯ä»¥æ‰“å°å‡ºæ¥çœ‹çœ‹ã€‚è¿™5ä¸ªå…ƒç´ å°†æ˜¯æ²¡æœ‰è§„å¾‹çš„ä¸€ä¸²æ•°å­—ï¼Œå› ä¸ºå¯¹åº”çš„è¿™å—å†…å­˜æ²¡æœ‰è¢«åˆå§‹åŒ–è¿‡ã€‚

### nth
### setNth
### insertNth
### removeNth

ðŸš§æ–½å·¥ä¸­ðŸš§

## æŒ‘æˆ˜

åœ¨å®žé™…ä½¿ç”¨ä¸­ï¼Œè¿˜æœ‰å¾ˆå¤šæˆ‘ä»¬æ²¡æœ‰å®žçŽ°çš„å¸¸ç”¨æ–¹æ³•ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ç»™å‡ºå…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œç»™ä½ ä½œä¸ºæŒ‘æˆ˜ã€‚

1. reverseï¼šç¿»è½¬åˆ—è¡¨ï¼Œä¾‹å¦‚åˆ—è¡¨`1, 2, 3`åœ¨ç¿»è½¬åŽå˜ä¸º`3, 2, 1`ï¼›
2. popï¼šåˆ é™¤æœ€åŽä¸€ä¸ªå…ƒç´ ï¼Œç„¶åŽè¿”å›žè¿™ä¸ªå…ƒç´ ï¼›
3. clearï¼šåˆ é™¤æ‰€æœ‰å…ƒç´ ï¼›

## å®Œæ•´ä»£ç  {#full-code}

::: details 02_array.zig
```zig
const std = @import("std");

pub fn SimpleArrayList(comptime T: type) type {
    return struct {
        const DefaultCapacity: usize = 10;
        const This = @This();
        allocator: std.mem.Allocator,
        items: []T,
        len: usize,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .items = try allocator.alloc(T, This.DefaultCapacity),
                .len = 0,
            };
        }

        pub fn enlarge(self: *This) !void {
            const new_capacity: usize = @intFromFloat(@as(f32, @floatFromInt(self.items.len)) * @as(f32, 1.5));
            const new_items = try self.allocator.alloc(T, new_capacity);
            std.mem.copyForwards(T, new_items, self.items);
            self.allocator.free(self.items);
            self.items = new_items;
        }

        pub fn append(self: *This, v: T) !void {
            if (self.len >= self.items.len) {
                try self.enlarge();
            }
            self.items[self.len] = v;
            self.len += 1;
        }

        pub fn insertNth(self: *This, n: usize, v: T) !void {
            if (n > self.len) {
                return error.IndexOutOfBound;
            }
            if (self.len >= self.items.len) {
                try self.enlarge();
            }
            var i = self.len;
            while (i >= n + 1) : (i -= 1) {
                self.items[i] = self.items[i - 1];
            }
            self.items[n] = v;
            self.len += 1;
        }

        pub fn nth(self: This, n: usize) !T {
            if (n >= self.len) {
                return error.IndexOutOfBound;
            }
            return self.items[n];
        }

        pub fn setNth(self: *This, n: usize, v: T) !void {
            if (n >= self.len) {
                return error.IndexOutOfBound;
            }
            self.items[n] = v;
        }

        pub fn removeNth(self: *This, n: usize) !T {
            if (n >= self.len) {
                return error.IndexOutOfBound;
            }
            const temp = self.items[n];
            for (n..self.len - 1) |i| {
                self.items[i] = self.items[i + 1];
            }
            self.len -= 1;
            return temp;
        }

        pub fn print(self: This) void {
            for (0..self.len) |i| {
                std.debug.print("{}, ", .{self.items[i]});
            }
            std.debug.print("\n", .{});
        }

        pub fn deinit(self: This) void {
            self.allocator.free(self.items);
        }
    };
}
```
:::

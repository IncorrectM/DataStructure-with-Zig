# Linked List é“¾è¡¨

é“¾è¡¨æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œå®ƒé€šè¿‡æŒ‡é’ˆé“¾æ¥ä¸€ç³»åˆ—èŠ‚ç‚¹æ¥å­˜å‚¨æ•°æ®ã€‚

ä½ å¯ä»¥æƒ³è±¡ä¸ºç«™åœ¨ä¸åŒåœ°æ–¹çš„äººæ‰‹é‡Œæ‹¿ç€ç»³å­è¿åœ¨ä¸€èµ·ï¼Œè™½ç„¶ä¸çŸ¥é“å½¼æ­¤å…·ä½“åœ¨å“ªï¼Œä½†æ€»æ˜¯å¯ä»¥é€šè¿‡ç»³å­è¿›è¡Œæ²Ÿé€šã€‚

![é“¾è¡¨ç¤ºæ„](./imgs/03/0301_linked_list.png)

åœ¨å¼€å§‹å‰ï¼Œæˆ‘è¿˜è¦å†é‡å¤ä¸€éæˆ‘çš„æ„è§ï¼šä¸è¦å°†æˆ‘ä»¬å®ç°çš„ä»£ç æŠ•å…¥åˆ°ç”Ÿäº§ä¸­ã€‚Zigæ ‡å‡†åº“æä¾›äº†[std.SinglyLinkedList](https://ziglang.org/documentation/master/std/#std.SinglyLinkedList)è¿™ä¸€å®ç°ã€‚

## èŠ‚ç‚¹

åœ¨é“¾è¡¨ä¸­ï¼Œæ‰€æœ‰çš„æ•°æ®éƒ½è¢«ä¿å­˜åœ¨**èŠ‚ç‚¹**ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ç€æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚

è®©æˆ‘ä»¬ä»å®šä¹‰èŠ‚ç‚¹å¼€å§‹ã€‚

```zig -skip
pub fn LinkedListNode(comptime T: type) type {
    return struct {
        const This = @This();
        data: T,
        next: ?*This,

        pub fn init(data: T) This {
            return .{
                .data = data,
                .next = null,
            };
        }
    };
}
```

æ˜¾è€Œæ˜“è§çš„ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªinitå‡½æ•°æ¥åˆå§‹åŒ–èŠ‚ç‚¹ã€‚ä¸è¿‡æˆ‘ä»¬ä¸éœ€è¦deinitå‡½æ•°ï¼Œæˆ‘ä»¬ä¼šå°†æ‰€æœ‰èŠ‚ç‚¹çš„deinitæ”¾ç½®åœ¨é“¾è¡¨ä¸­ã€‚

## é“¾è¡¨çš„åˆå§‹åŒ–å’Œååˆå§‹åŒ–

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å®ç°é“¾è¡¨æœ€åŸºæœ¬çš„ä¸¤ä¸ªå‡½æ•°â€”â€”åˆå§‹åŒ–å’Œååˆå§‹åŒ–ã€‚

```zig -skip
const std = @import("std");
pub fn LinkedList(comptime T: type) type {
    return struct {
        const Node = LinkedListNode(T);
        const This = @This();
        allocator: std.mem.Allocator,
        head: ?*Node,
        length: usize,

        pub fn init(allocator: std.mem.Allocator) This {
            return .{
                .allocator = allocator,
                .head = null,
                .length = 0,
            };
        }

        pub fn deinit(self: *This) void {
            var next = self.head;
            while (next != null) {
                const cur = next.?;
                next = cur.next;
                switch (@typeInfo(T)) {
                    .@"struct", .@"enum", .@"union" => {
                        if (@hasDecl(T, "deinit")) {
                            // ååˆå§‹åŒ–èŠ‚ç‚¹é‡Œçš„æ•°æ®
                            cur.data.deinit();
                        }
                    },
                    else => {},
                }
                // é‡Šæ”¾èŠ‚ç‚¹
                self.allocator.destroy(cur);
            }
        }
    };
}
```

æˆ‘ä»¬ä»æˆå‘˜å¼€å§‹çœ‹èµ·ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬è¦ä¿å­˜èŠ‚ç‚¹çš„ç±»å‹ä¸ºNodeï¼Œä¿å­˜æœ¬èº«çš„ç±»å‹Thisã€‚æˆ‘ä»¬éœ€è¦ä¿å­˜ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚å¦å¤–ï¼Œä¸ºäº†æ–¹ä¾¿åˆ¤æ–­é•¿åº¦ï¼Œæˆ‘ä»¬ä¿å­˜é•¿åº¦ä¸ºlengthã€‚

::: details ä¸ºä»€ä¹ˆä¿å­˜length?
å’Œåˆ—è¡¨ä¸€æ ·ï¼Œé“¾è¡¨çš„é•¿åº¦åº”è¯¥ç­‰äºé“¾è¡¨ä¸­å…ƒç´ çš„æ•°é‡ã€‚

å› ä¸ºé“¾è¡¨ä¸­çš„å…ƒç´ æ˜¯åˆ†æ•£åœ¨å„å¤„çš„ï¼Œå¿…é¡»è¦é€šè¿‡æŒ‡é’ˆä¸€ä¸ªä¸€ä¸ªæ•°ã€‚æ²¿ç”¨å‰é¢çš„æ¯”å–»ï¼Œå°±åƒè®©äººé€šè¿‡ç»³å­ä¸€ä¸ªä¸€ä¸ªæŠ¥æ•°ã€‚æ˜¾ç„¶ï¼Œä¼´éšç€äººè¶Šæ¥è¶Šå¤šï¼Œè¿™ä¸ªè¿‡ç¨‹å°†ä¼šè¶Šæ¥è¶Šæ…¢ã€‚

ä¸ºäº†åŠ é€Ÿè¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬ç›´æ¥ä¿å­˜é•¿åº¦ï¼Œåœ¨å¢åŠ èŠ‚ç‚¹å’Œåˆ é™¤èŠ‚ç‚¹æ—¶ä¿®æ”¹è¿™ä¸ªå€¼ã€‚
:::

ç„¶åï¼Œè®©æˆ‘ä»¬çœ‹åˆå§‹åŒ–å‡½æ•°ã€‚åˆå§‹åŒ–å‡½æ•°éå¸¸çš„æ™®é€šï¼Œåªæ˜¯ä¿å­˜ä¸€äº›å¿…è¦çš„ä¿¡æ¯ã€‚

æœ€åæ˜¯ååˆå§‹åŒ–æ–¹æ³•ã€‚

ç¬¬ä¸€çœ¼æœ›å»ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªå…ˆå‰æ²¡æœ‰è§è¿‡çš„å‡½æ•°`@hasDecl()`ã€‚è¿™åŒæ ·æ˜¯ä¸€ä¸ªå†…å»ºå‡½æ•°ï¼Œå®ƒå¯ä»¥åˆ¤æ–­ä¼ å…¥çš„ç±»å‹ï¼ˆç¬¬ä¸€ä¸ªå‚æ•°ï¼‰æ˜¯å¦å£°æ˜äº†ç»™å®šçš„æˆå‘˜ï¼ˆç¬¬äºŒä¸ªå‚æ•°ï¼‰ã€‚è¿™æœ‰ä¸€ç‚¹åƒä¸€äº›è¯­è¨€ä¸­çš„åå°„ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬é€šè¿‡è¿™ä¸ªå‡½æ•°æ¥åˆ¤æ–­èŠ‚ç‚¹é‡Œçš„æ•°æ®éœ€ä¸éœ€è¦ååˆå§‹åŒ–ï¼Œéœ€è¦åˆ™æ‰§è¡Œååˆå§‹åŒ–ã€‚

ç„¶åæ˜¯ä¸€äº›ç¥å¥‡çš„æ ‡è¯†ç¬¦ï¼š`@"struct"`,`@"enum"`ä»¥åŠ`@"union"`ã€‚è¿™äº›æ˜¯Zigä¸­çš„ä¸€äº›ç‰¹æ®Šè¯­æ³•ï¼Œä»¥è¿™ç§æ–¹å¼å¯ä»¥è®©æ ‡è¯†ç¬¦ç­‰äºå…³é”®è¯ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è¦åˆ¤æ–­Tæ˜¯ä¸æ˜¯ç»“æ„ä½“ï¼Œæšä¸¾æˆ–è€…è”åˆï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨åˆ°äº†å†…å»ºå‡½æ•°`@typeInfo(T)`ã€‚

è¿™é‡Œæˆ‘ä»¬è¿˜ä½¿ç”¨åˆ°äº†`switch`è¯­æ³•ã€‚`switch`æ˜¯ä¸€ç§ç©·ä¸¾çš„åŒ¹é…ï¼Œé€ä¸ªå¯¹æ¯”ç»™å®šçš„å€¼æ˜¯å¦ç¬¦åˆåˆ—å‡ºçš„å€¼ï¼Œç„¶åæ‰§è¡Œç¬¬ä¸€ä¸ªç¬¦åˆçš„å€¼åé¢çš„ä»£ç ï¼Œå¦‚æœéƒ½ä¸ç¬¦åˆå°±æ‰§è¡Œelseåé¢çš„ä»£ç ã€‚

Okï¼Œåˆ°è¿™é‡Œæˆ‘ä»¬å¯ä»¥æƒ³æƒ³éœ€è¦ä»€ä¹ˆæ–¹æ³•äº†ã€‚

## é“¾è¡¨çš„å¸¸ç”¨æ–¹æ³•

ç±»ä¼¼äºåˆ—è¡¨ï¼Œæˆ‘ä»¬ç¬¬ä¸€ä¸ªæƒ³åˆ°çš„å°±æ˜¯æœ€åŸºæœ¬çš„å¢åˆ æŸ¥æ”¹ï¼š

1. nth(n)ï¼šè·å–ç¬¬nä¸ªèŠ‚ç‚¹ï¼›
2. append(v)ï¼šåœ¨é“¾è¡¨æœ«å°¾è¿½åŠ å…ƒç´ vï¼›
3. remove(node)ï¼šä»é“¾è¡¨ä¸­ç§»é™¤èŠ‚ç‚¹nodeï¼›

å’Œåˆ—è¡¨ä¸åŒï¼Œåœ¨é“¾è¡¨ä¸­æˆ‘ä»¬ä¸€èˆ¬ä¸é€šè¿‡ä¸‹æ ‡è®¿é—®ã€‚æˆ‘ä»¬ä¸»è¦è®¿é—®ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜æœ‰ä¸‹é¢çš„æ–¹æ³•ï¼š

1. prepend(v)ï¼šåœ¨é“¾è¡¨å¤´æ’å…¥å…ƒç´ vï¼›
2. popFirst()ï¼šç§»é™¤é“¾è¡¨å¤´ä¸Šçš„èŠ‚ç‚¹ï¼›
3. popLast()ï¼šç§»é™¤é“¾è¡¨æœ«å°¾çš„èŠ‚ç‚¹ï¼›

::: tip
åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨å…ƒç´ ä½œä¸ºæ’å…¥çš„å•ä½ï¼Œè¿™æ ·å­æˆ‘ä»¬å¯ä»¥è®©é“¾è¡¨è‡ªå·±æ¥è´Ÿè´£èŠ‚ç‚¹çš„åˆå§‹åŒ–å’Œååˆå§‹åŒ–ã€‚ä½†åœ¨ä¸€äº›å®ç°ä¸­ï¼Œæ’å…¥çš„å•ä½æ˜¯èŠ‚ç‚¹ï¼Œä¾‹å¦‚Zigçš„æ ‡å‡†åº“[std.SinglyLinkedList](https://ziglang.org/documentation/master/std/#std.SinglyLinkedList)ã€‚
:::

### nth

æˆ‘ä»¬è¦ä¸€ä¸ªä¸€ä¸ªæ•°è¿‡æ¥ï¼Œç›´åˆ°æ•°åˆ°ç¬¬nä¸ªæœªçŸ¥ã€‚

å› ä¸ºæˆ‘ä»¬åœ¨ç»“æ„ä½“ä¸­ä¿å­˜äº†é“¾è¡¨çš„é•¿åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªä¸€ä¸ªæ‰¾ä¹‹å‰å…ˆåˆ¤æ–­æœ‰æ²¡æœ‰ã€‚ä¸è¿‡ï¼Œåœ¨é“¾è¡¨ä¸­ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¸ä¼šè¿”å›ä¸‹æ ‡è¶Šç•Œé”™è¯¯ï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªç©ºå€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬æ²¡æ‰¾åˆ°ã€‚

äºæ˜¯ï¼Œæˆ‘ä»¬æœ‰è¿™æ ·çš„å®ç°ï¼š

```zig -skip
pub fn nth(self: This, n: usize) ?T {
    if (n >= self.length) {
        return null;
    }
    var next = self.head;
    var i: usize = 0;
    while (next != null and i != n) : (i += 1) {
        next = next.?.next;
    }
    return next;
}
```

### append

è¦åœ¨å°¾éƒ¨æ’å…¥å…ƒç´ ï¼Œä¸»è¦çš„æ­¥éª¤ä¸ºï¼š

1. æ‰¾åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼›
2. åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œè¿™ä¸ªæ–°èŠ‚ç‚¹åŒ…å«æ’å…¥çš„å…ƒç´ ï¼›
3. è®©æœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹ï¼›

å¯ä»¥æœ‰è¿™æ ·çš„å®ç°ï¼š

```zig -skip
pub fn append(self: *This, v: T) !void {
    // 2. åˆ›å»ºæ–°èŠ‚ç‚¹
    const new_node = try self.allocator.create(This.Node);
    new_node.data = v;
    new_node.next = null;
    if (self.head == null) {
        self.head = new_node;
        self.length += 1;
        return;
    }
    // 1. æ‰¾åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹
    var last: ?*This.Node = self.head.?;
    while (true) {
        if (last.?.next == null) {
            break;
        } else {
            last = last.?.next;
        }
    }
    // 3. è®©æœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹
    last.?.next = new_node;
    self.length += 1;
}
```

æ³¨æ„åˆ°ï¼Œåœ¨å®é™…å®ç°ä¸­ï¼Œæˆ‘ä»¬æŠŠ2æå‰äº†ä¸€ç‚¹ã€‚å› ä¸ºæˆ‘ä»¬çš„é“¾è¡¨æœ‰ä¸€ä¸ªç‰¹æ®Šçš„èŠ‚ç‚¹â€”â€”headã€‚ä¸ºäº†ç®€åŒ–åé¢çš„ä»£ç ï¼Œæˆ‘ä»¬æå‰åˆ¤æ–­å½“å‰è¦è¿½åŠ çš„èŠ‚ç‚¹æ˜¯ä¸æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ˜¯åˆ™ç›´æ¥æ”¹headï¼Œä¸æ˜¯åˆ™è¿›å…¥æˆ‘ä»¬ä¸Šé¢è¯´çš„æµç¨‹ã€‚

### remove
### prepend
### popFirst

## æµ‹è¯•

### append

å’Œåˆ—è¡¨ä¸€æ ·ï¼Œæˆ‘ä»¬å…ˆæµ‹è¯•`append`ã€‚

```zig -test_collect_1
const std = @import("std");
const expect = std.testing.expect;
test "test append" {
    // åˆå§‹åŒ–é“¾è¡¨
    const allocator = std.testing.allocator;
    var list = LinkedList(i32).init(allocator);
    defer list.deinit();

    // æµ‹è¯•æ’å…¥ä¸€äº›æ•°æ®
    for (0..17) |value| {
        const v: i32 = @intCast(value);
        try list.append(v);
    }
    try expect(list.head != null);
    try expect(list.head.?.data == 0);
    try expect(list.length == 17);
}
```

## æŒ‘æˆ˜ - åŒé“¾è¡¨

ğŸš§æ–½å·¥ä¸­ğŸš§
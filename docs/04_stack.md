# Stack æ ˆ

æ ˆåŒæ ·æ˜¯ä¸€ç§çº¿æ€§ç»“æ„ï¼Œå®ƒåªå…è®¸åœ¨æœ«å°¾è¿›è¡Œæ“ä½œï¼Œå¹¶ä¸”éµå¾ªâ€œå…ˆè¿›åå‡ºâ€çš„åŸåˆ™ã€‚

ä¸¾ä¸ªä¾‹å­ï¼Œå †åœ¨æ¡Œå­ä¸Šçš„ä¸€å ä¹¦å¯ä»¥çœ‹ä½œä¸€ä¸ªæ ˆã€‚æ”¾ä¹¦æ—¶ï¼Œåªèƒ½æ”¾åœ¨æœ€ä¸Šé¢ï¼ˆæœ«å°¾ï¼‰ï¼Œæ‹¿ä¹¦æ—¶ä¹Ÿåªèƒ½æ‹¿æœ€ä¸Šé¢é‚£æœ¬ï¼ˆæœ«å°¾æœ€åä¸€ä¸ªå…ƒç´ ï¼‰ã€‚è¦æ‹¿å‡ºæœ€åº•ä¸‹çš„ä¹¦ï¼Œå¿…é¡»ä»æœ€é¡¶ä¸Šçš„ä¹¦å¼€å§‹ä¸€æœ¬ä¸€æœ¬æ‹¿ä¸‹æ¥ï¼Œè¿™å°±æ˜¯â€œå…ˆè¿›å…ˆå‡ºâ€ã€‚

æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†å€ŸåŠ©ç¬¬äºŒç« ä¸­å®ç°çš„åˆ—è¡¨`SimpleArrayList`æ¥å®ç°æ ˆã€‚å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘è¿˜æ˜¯ä¸å»ºè®®å°†æœ¬ä¹¦ä¸­å®ç°çš„ç¨‹åºç”¨åœ¨å®è·µä¸­ã€‚

## å‡†å¤‡å·¥ä½œ

åœ¨æ­£å¼å¼€å§‹ä»‹ç»å’Œå®ç°åŸºæœ¬æ“ä½œå‰ï¼Œè®©æˆ‘ä»¬å…ˆå®ç°ä¸€äº›åŸºç¡€çš„å‡½æ•°å’Œæ–¹æ³•ã€‚

```zig
pub fn Stack(T: type) type {
    return struct {
        const This = @This();
        const List = ArrayList(T);
        allocator: std.mem.Allocator,
        data: This.List,

        pub fn init(allocator: std.mem.Allocator) !This {
            return .{
                .allocator = allocator,
                .data = try This.List.init(allocator),
            };
        }

        pub fn top(self: This) usize {
            return self.data.len;
        }

        pub fn isEmpty(self: This) bool {
            return self.top() == 0;
        }

        pub fn deinit(self: *This) void {
            self.data.deinit();
        }
    };
}
```

é¦–å…ˆï¼Œæˆ‘ä»¬ä¿å­˜äº†Thiså’ŒListä¸¤ä¸ªç±»å‹ï¼Œæ¥æ–¹ä¾¿æˆ‘ä»¬çš„åç»­ä½¿ç”¨ã€‚é€šè¿‡ä¿å­˜Listï¼Œåœ¨æœ‰éœ€è¦çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æ–¹ä¾¿åœ°æŠŠListçš„å€¼ä¿®æ”¹ä¸ºå…¶ä»–å€¼ï¼Œè€Œä¸ç”¨ä¿®æ”¹ä»£ç ä¸­å…¶ä»–å‡ºç°Listçš„åœ°æ–¹ã€‚å½“ç„¶ï¼Œåœ¨æˆ‘ä»¬ç®€å•çš„å®ç°ä¸­ï¼Œè¿™å¹¶ä¸æ˜¯å¿…è¦çš„ã€‚

éšåï¼Œæˆ‘ä»¬ä¿å­˜äº†ä¸€ä¸ªallocatorï¼Œå¹¶ç”¨è¿™ä¸ªallocatoråˆå§‹åŒ–äº†ä¸€ä¸ªåˆ—è¡¨çš„ç¤ºä¾‹ç”¨æ¥ä¿å­˜æ•°æ®ã€‚

ç„¶åï¼Œæˆ‘ä»¬åˆ›å»ºäº†åˆå§‹åŒ–å‡½æ•°initå’Œååˆå§‹åŒ–æ–¹æ³•deinitï¼Œè¿™ä¸ªå’Œå‰é¢çš„æ²¡æœ‰å·®åˆ«ã€‚

æœ€åï¼Œæˆ‘ä»¬åˆ›å»ºäº†`top`æ–¹æ³•å’Œ`isEmpty`æ–¹æ³•ã€‚`top`æ–¹æ³•è¿”å›ä¸‹ä¸€ä¸ªè¿›å…¥åˆ°æ ˆä¸­ï¼ˆå…¥æ ˆï¼‰çš„å…ƒç´ åº”è¯¥è¢«ä¿å­˜åˆ°å“ªï¼Œè€Œ`isEmpty`æ–¹æ³•åˆ¤æ–­æ ˆæ˜¯ä¸æ˜¯ä¸ºç©ºã€‚æˆ‘ä»¬å°†ä¼šè¿›åœºç”¨åˆ°è¿™ä¸¤ä¸ªæ–¹æ³•ï¼ŒæŠŠå®ƒä»¬ä½œä¸ºå•ç‹¬çš„æ–¹æ³•å¯ä»¥è®©æˆ‘ä»¬çš„ç¨‹åºæ›´åŠ æ¸…æ™°ï¼Œä¹Ÿæ›´åŠ ä¾¿äºä¿®æ”¹ã€‚

## åŸºæœ¬æ“ä½œ

æ ˆå¹¶ä¸å¤æ‚ï¼Œå®ƒæœ‰ä¸‹é¢çš„ä¸»è¦æ–¹æ³•ï¼š

1. pushï¼šå…¥æ ˆä¸€ä¸ªå…ƒç´ ï¼›
2. popï¼šè¿”å›æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¹¶ä»æ ˆä¸­ç§»é™¤è¿™ä¸ªå…ƒç´ ï¼›
3. peekï¼šè¿”å›æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä½†ä¸ç§»é™¤ï¼›

å€ŸåŠ©äºå…ˆå‰å®ç°çš„SimpleArrayListï¼Œæˆ‘ä»¬å¯ä»¥ä¸ç”¨æ‰‹åŠ¨ç®¡ç†å†…å­˜äº†ï¼

æˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªæ¥ã€‚

### push

çœ‹ç€`push`çš„åŠŸèƒ½ï¼Œä½ æœ‰æ²¡æœ‰è§‰å¾—çœ¼ç†Ÿï¼Ÿæ²¡é”™ï¼Œåˆ—è¡¨çš„`append`å’Œå®ƒæœ‰ç€å‡ ä¹ä¸€æ ·çš„åŠŸèƒ½ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„å®ç°åªæ˜¯ç®€å•çš„åœ¨`append`ä¹‹å¤–å¥—äº†ä¸€å±‚ã€‚

```zig
pub fn push(self: *This, v: T) !void {
    try self.data.append(v);
}
```

### pop

è®°å¾—ç¬¬äºŒç« çš„æŒ‘æˆ˜å—ï¼Ÿå¦‚æœä½ å®Œæˆäº†æŒ‘æˆ˜ï¼Œé‚£ä¹ˆè¿™é‡Œçš„`pop`å¯ä»¥ç›´æ¥ä½¿ç”¨ä¹‹å‰å®ç°çš„popã€‚

å¦‚æœæ²¡æœ‰ï¼Œå…¶å®ä¹Ÿå¾ˆç®€å•ï¼šé€šè¿‡nthè·å¾—æœ€åä¸€ä¸ªå…ƒç´ ï¼Œåœ¨é€šè¿‡removeNthåˆ é™¤è¿™ä¸ªå…ƒç´ å°±è¡Œã€‚å› ä¸ºæˆ‘ä»¬åˆ é™¤çš„æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥ä¸ç”¨removeNthï¼Œç›´æ¥é•¿åº¦å‡ä¸€å°±è¡Œã€‚

äºæ˜¯ï¼Œæˆ‘ä»¬æœ‰ä¸‹é¢çš„å®ç°ï¼š

```zig
pub fn pop(self: *This) ?T {
    if (self.isEmpty()) {
        // ç©ºæ ˆ
        return null;
    }
    const lastIndex = self.top() - 1;
    //                                      ğŸ‘‡ çœ‹è¿™é‡Œ ğŸ‘‡
    const last = self.data.nth(lastIndex) catch unreachable;
    // ä½¿ç”¨å‡½æ•°è¿›è¡Œä¿®æ”¹
    // self.data.removeNth(lastIndex);
    // æˆ–è€…æ‰‹åŠ¨ä¿®æ”¹
    self.data.len -= 1;
    return last;
}
```

æ³¨æ„çœ‹ï¼Œæˆ‘ä»¬åˆé‡åˆ°äº†æ²¡è§è¿‡çš„ä¸œè¥¿ï¼

è®©æˆ‘ä»¬å›é¡¾å‰é¢å®ç°çš„`SimpleArrayList`ï¼Œæˆ‘ä»¬ä¼šå‘ç°`nth`å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªé”™è¯¯è”åˆç±»å‹ï¼Œå¿…é¡»è¦å¤„ç†é”™è¯¯æ‰èƒ½æ‹¿åˆ°å®é™…çš„å€¼ã€‚

åœ¨ä»¥å‰çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡`try`å…³é”®å­—å¤„ç†é”™è¯¯â€”â€”é‡åˆ°é”™è¯¯æ—¶è¿”å›é”™è¯¯ï¼Œå¦åˆ™è·å¾—å…·ä½“å€¼ã€‚`catch`ä¹Ÿæ˜¯ç”¨æ¥å¤„ç†é”™è¯¯çš„ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥è¯´æ˜ï¼š

```zig
const std = @import("std");

pub fn errorIfZero(v: i32) !i32 {
    if (v == 0) {
        return error.Zero;
    } else {
        return v;
    }
}

pub fn main() !void {
    _ = errorIfZero(10086) catch {
        std.debug.print("I will not be printed.\n", .{});
    };

    _ = errorIfZero(0) catch {
        std.debug.print("I will be printed since you passed 0.\n", .{});
    };

    _ = errorIfZero(0) catch |err| {
        std.debug.print("Caught an error {!}\n", .{err});
    };
}
```

```ansi
$stdout returns nothing.
$stderr:
I will be printed since you passed 0.
Caught an error error.Zero
```

æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ï¼Œåœ¨ä¼ å…¥0æ—¶è¿”å›é”™è¯¯ï¼Œå¦åˆ™è¿”å›ä¼ å…¥çš„æ•°å­—ã€‚

ç¬¬ä¸€ä¸ª`catch`åé¢çš„è¯­å¥ä¸ä¼šè¢«è°ƒç”¨ï¼Œå› ä¸º`errorIfZero(10086)`ä¼šè¿”å›10086ï¼›ç¬¬äºŒä¸ª`catch`åé¢çš„è¯­å¥ä¼šè¢«è°ƒç”¨ï¼Œå› ä¸º`errorIfZero(0)`ä¼šè¿”å›é”™è¯¯error.Zeroï¼›è€Œåœ¨ç¬¬ä¸‰ä¸ª`catch`åé¢çš„è¯­å¥ä¸­ï¼Œæˆ‘ä»¬æ•è·äº†è¿”å›çš„é”™è¯¯ï¼Œå¹¶ä¸”æ‰“å°äº†é”™è¯¯çš„å€¼ã€‚

é€šè¿‡`catch`å…³é”®å­—ï¼Œæˆ‘ä»¬èƒ½æ›´åŠ çµæ´»çš„å¤„ç†é”™è¯¯è”åˆç±»å‹ã€‚

### peek

`peek`çš„åŠŸèƒ½æœ‰ä¸€ç‚¹åƒ`pop`ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨popçš„åŸºç¡€ä¸Šåšä¿®æ”¹ã€‚

```zig
pub fn peek(self: *This) ?T {
    if (self.isEmpty()) {
        // ç©ºæ ˆ
        return null;
    }
    const lastIndex = self.top() - 1;
    const last = self.data.nth(lastIndex) catch unreachable;
    return last;
}
```

::: tip
Zigä¸­ï¼Œå‚æ•°å’Œè¿”å›å€¼æ€»æ˜¯**æŒ‰å€¼ä¼ é€’**çš„ï¼Œä¼ å…¥çš„å‚æ•°å’Œè¿”å›çš„å€¼éƒ½æ˜¯åŸå§‹å€¼çš„ä¸€ä»½å¤åˆ¶ã€‚

å› æ­¤ï¼Œé€šè¿‡`peek`è·å¾—çš„å…ƒç´ åªæ˜¯æ ˆé¡¶å…ƒç´ çš„ä¸€æ¯”ä¸€å¤åˆ»ï¼Œä¿®æ”¹è·å¾—çš„å…ƒç´ å¹¶ä¸ä¼šä¿®æ”¹æ ˆé¡¶çš„é‚£ä¸ªå…ƒç´ ã€‚

ä½ ä¹Ÿå¯ä»¥å®ç°`peekRef`æ–¹æ³•ï¼Œè·å¾—æŒ‡å‘æ ˆé¡¶å…ƒç´ çš„æŒ‡é’ˆè€Œä¸æ˜¯å¤åˆ¶ã€‚
:::

## æµ‹è¯•

### push

æˆ‘ä»¬è¦ä¿è¯æ•°æ®æ­£ç¡®åœ°å…¥æ ˆï¼Œå¹¶ä¸”æ²¡æœ‰å½±å“å‰é¢çš„æ•°æ®ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ç›´æ¥æ–¹ä½`data`æˆå‘˜å†…éƒ¨çš„`items`æˆå‘˜æ¥åšå‡ºåˆ¤æ–­ã€‚

```zig
test "test push" {
    var stack = try Stack(i32).init(allocator);
    defer stack.deinit();

    const expected = [_]i32{ 1, 3, 4, 9, 1, 0, 111, 19928, 31415, 8008820 };
    for (expected) |value| {
        try stack.push(value);
        // æµ‹è¯•å…ƒç´ æ˜¯å¦æ­£ç¡®åœ°å…¥æ ˆ
        try expect(stack.top() != 0);
        try expect(stack.data.items[stack.top() - 1] == value);
    }
    try expect(std.mem.eql(i32, &expected, stack.data.items));
}
```

### pop

æˆ‘ä»¬å¯ä»¥å‡†å¤‡ä¸€ç»„æ•°æ®ï¼Œå°†å®ƒä»¬æŒ‰é¡ºåºå…¥æ ˆã€‚ç„¶åå°†å®ƒä»¬çš„é¡ºåºç¿»è½¬è¿‡æ¥ï¼Œå†é€ä¸ªå‡ºæ ˆï¼Œç¡®ä¿å®ç°äº†â€œå…ˆè¿›åå‡ºâ€ã€‚æœ€åï¼Œæˆ‘ä»¬å†è¯•è¯•å¼¹å‡ºç©ºæ ˆèƒ½ä¸èƒ½è¿”å›ç©ºå€¼ã€‚

```zig
test "test pop" {
    var stack = try Stack(i32).init(allocator);
    defer stack.deinit();

    var expected = [_]i32{ 1, 3, 4, 9, 1, 0, 111, 19928, 31415, 8008820 };
    for (expected) |value| {
        try stack.push(value);
    }

    // å‡ºæ ˆåº”è¯¥æ˜¯å…ˆè¿›åå‡º
    std.mem.reverse(i32, &expected);
    // ä¸€ä¸ªä¸ªå‡ºæ ˆå¹¶æ£€æŸ¥æ˜¯å¦ç¬¦åˆé¢„æœŸ
    for (expected) |value| {
        const poped = stack.pop();
        try expect(poped != null and poped.? == value);
    }

    // è¯•å›¾å¼¹å‡ºç©ºæ ˆä¼šè¿”å›ç©ºå€¼
    try expect(stack.pop() == null);
}
```

### peek

```zig
test "test peek" {
    var stack = try Stack(i32).init(allocator);
    defer stack.deinit();

    // è¯•å›¾peekç©ºæ ˆä¼šè¿”å›ç©ºå€¼
    try expect(stack.peek() == null);

    const expectedSource = [_]i32{ 1, 3, 4, 9, 1, 0, 111, 19928, 31415, 8008820 };
    for (expectedSource) |value| {
        try stack.push(value);
    }
    const expected = expectedSource[expectedSource.len - 1]; // é¢„æœŸçš„peekç»“æœ

    // æ— è®ºpeekå‡ æ¬¡ï¼Œè¿”å›çš„æ€»æ˜¯æ ˆé¡¶å…ƒç´ 
    for (expected) |_| {
        const peeked = stack.peek();
        try expect(peeked != null and peeked.? == expected);
    }
}
```

## åº”ç”¨ç¤ºä¾‹ - æ‹¬å·åŒ¹é…

## æŒ‘æˆ˜

## å®Œæ•´ä»£ç 

ğŸš§æ–½å·¥ä¸­ğŸš§

